#TouhouDanmakufu[Player]
#ScriptVersion[3]
#Title["Yabusame Houren"]
#ID["Yabusame"]
#Text["Flawless Thoughtlessness"]
#ReplayName["Yabusame"]

#include "./lib/lib_player.dnh"

int _count = 0; //shot type spread effect
int _countShot = 0; //shot type stagger

@Initialize {
    string imageFile = IMG_PLR_YABUSAME;
    string shotData = DIR_PLR ~ "YabuShot.dnh";
    InitPlayer(imageFile, shotData, 3, 1.53);

    TShot();
    TOption(1);
    TOption(-1);
}

@MainLoop {
    _count++;
    if (Shooting() && !IsPlayerSpellActive() && Alive()) _countShot++;
    else _countShot = -1;
    yield;
}

@Event { PlayerEvent(); }

@Finalize {}

task TShot() {
    loop {
        if (Shooting() && !IsPlayerSpellActive() && Alive() && _countShot % 10 == 0) {
            if (GetVirtualKeyState(VK_SLOWMOVE) != KEY_HOLD && GetVirtualKeyState(VK_SLOWMOVE) != KEY_PUSH) {
                loop (3) { //unfocus shot
                    int offset = 80;
                    ascent (i in 1..7) {
                        int shot = CreatePlayerShotA1(GetPlayerX(), GetPlayerY(), 28, 270 + 13*i*(sin(_count + i*offset)), 1, 1, 1);
                        int shot2 = CreatePlayerShotA1(GetPlayerX(), GetPlayerY(), 28, 270 - 13*i*(sin(_count + i*offset)), 1, 1, 1);
                        Obj_SetRenderPriorityI(shot, RP_STG_PLAYER);
                        Obj_SetRenderPriorityI(shot2, RP_STG_PLAYER);
                    }
                    CallSFX(SND_PL_SHOT);
                    loop (3) yield;
                }
            } else {
                loop (3) { //focus shot
                    real modifier = 15*sin(_count);
                    ascent (i in -5..6) {
                        int shot = CreatePlayerShotA1(GetPlayerX(), GetPlayerY(), 28, 270 + modifier*i, 1, 1, 1);
                        Obj_SetRenderPriorityI(shot, RP_STG_PLAYER);
                    }
                    CallSFX(SND_PL_SHOT);
                    loop (3) yield;
                }
            }
        }
        yield;
    }
}

task TOption(int dir_) {
    int distUnfocus = 32;
    int distFocus = 20;
    int distCurrent = distUnfocus;

    int objOption = ObjPrim_Create(OBJ_SPRITE_2D);
    ObjPrim_SetTexture(objOption, _pathImg);
    ObjSprite2D_SetSourceRect(objOption, 64, 48, 80, 64);
    ObjSprite2D_SetDestCenter(objOption);
    Obj_SetRenderPriorityI(objOption, RP_STG_PLAYER - 1i);

    TOptionShot();

    loop {
        real rotationX = cos(_count*4);
        distCurrent = (GetVirtualKeyState(VK_SLOWMOVE) != KEY_HOLD && GetVirtualKeyState(VK_SLOWMOVE) != KEY_PUSH) ? distUnfocus : distFocus;

        ObjRender_SetPosition(objOption, GetPlayerX() + distCurrent*dir_*rotationX, GetPlayerY() + distCurrent*dir_*sin(_count*5), 1);

        //Render over player as if rotating around them
        if (rotationX == dir_) Obj_SetRenderPriorityI(objOption, RP_STG_EFF_PLR_LO);
        else if (rotationX == -dir_) Obj_SetRenderPriorityI(objOption, RP_STG_EFF_PLR_HI);

        Obj_SetVisible(objOption, Alive());
        yield;
        
    }

    task TOptionShot() {
        loop {
            if (Shooting() && Alive() && !IsPlayerSpellActive() && _countShot % 10 == 0) {
                loop (3) {
                    real optionX = ObjRender_GetX(objOption);
                    real optionY = ObjRender_GetY(objOption);
                    real[][] enemy = GetEnemyIntersectionPosition(GetPlayerX(), GetPlayerY(), 1);
                    real angle = 270;
                    if (length(enemy) > 0) angle = atan2(enemy[0][1] - optionY, enemy[0][0] - optionX);
                    int shot = CreatePlayerShotA1(optionX, optionY, 28, angle, 4, 1, 2);
                    Obj_SetRenderPriorityI(shot, Obj_GetRenderPriorityI(objOption));
                    loop (3) yield;
                }
            }
            yield;
        }
    }
}

task TShotCancel(int obj_, real x_, real y_, int graphic_) { //Player shot deletion effect
    real angle = ObjMove_GetAngle(obj_);
    real speed = ObjMove_GetSpeed(obj_);
    x_ -= speed * cos(angle);
    y_ -= speed * sin(angle);
    real xStep = cos(angle);
    real yStep = sin(angle);
    real angleZ = graphic_ == 1 ? angle + 90 : 0;
    if (rand_int(1, 8) == 1) TShotParticle(x_, y_);
    
    real frame = 0;
    while (frame < 4) {
        ObjParticleList_SetPosition(_particleShot, x_, y_, 1);
        ObjParticleList_SetAngleZ(_particleShot, angleZ);
        ObjParticleList_SetExtraData(_particleShot, graphic_ + 5, trunc(frame), 0);
        ObjParticleList_AddInstance(_particleShot);

        frame += 1/2;
        x_ += xStep;
        y_ += yStep;
        yield;
    }
}

task TSpell() {
    int objManage = GetSpellManageObject();

    SetForbidPlayerShot(true);
    SetPlayerInvincibilityFrame(420);
    ObjRender_SetColor(_objPlayer, COLOR_WHITE);
    SetPlayerSpeed(1.53, 1.53);

    CallSFX(SND_PL_Y_SPELL1);
    
    real radius = 0;
    TEffect();

    loop (220) {
        radius += 4;
        yield;
    }
    wait(140);

    SetForbidPlayerSpell(true);
    SetForbidPlayerShot(false);
    SetPlayerSpeed(3, 1.53);
    Obj_Delete(objManage);
    wait(40);

    //vulnerability indicator
    CallSFX(SND_PL_VULNERABLE);
    radius = 28;
    int circle = InitPrim2D(PRIMITIVE_LINESTRIP, 17, RP_STG_EFF_PLR_HI);
    ascent (i in 0..17) {
        ObjPrim_SetVertexColor(circle, i, 170, 221, 255);
    }
    loop (20) {
        ascent (i in 0..17) {
            real angleT = 360/16 * i;
            ObjPrim_SetVertexPosition(circle, i, GetPlayerX() + radius*cos(angleT), GetPlayerY() + radius*sin(angleT), 1);
        }
        radius -= 28/20;
        yield;
    }

    Obj_Delete(circle);
    SetForbidPlayerSpell(false);

    task TEffect() {
        real playerX = GetPlayerX();
        real playerY = GetPlayerY();
        int circle = CreateCircle(playerX, playerY);
        int[] lines = []; 
        loop (10) lines = lines ~ [CreateLine(playerX, playerY)];

        while (!Obj_IsDeleted(objManage)) {
            //circle
            ascent (i in 1..34) {
                real angleT = 360/32 * i;
                ObjPrim_SetVertexPosition(circle, i, playerX + radius*cos(angleT), playerY + radius*sin(angleT), 1);
            }
            ObjSpell_SetIntersectionCircle(circle, playerX, playerY, radius);
            //lines
            ascent (i in 0..5) {
                real angleT;
                angleT = rand(0, 3600) / 10;
                ObjPrim_SetVertexPosition(lines[i], 1, playerX + radius*cos(angleT), playerY + radius*sin(angleT), 1);
                angleT = rand(0, 3600) / 10;
                ObjPrim_SetVertexPosition(lines[i + 5], 1, playerX + radius/2*cos(angleT), playerY + radius/2*sin(angleT), 1);
            }
            DeleteShotInCircle(TYPE_SHOT, TYPE_IMMEDIATE, playerX, playerY, radius);
            yield;
        }

        ascent (i in 0..34) ObjPrim_SetVertexColor(circle, i, COLOR_WHITE);
        CallSFX(SND_PL_Y_SPELL2);
        yield;

        ascent (i in 0..10) Obj_Delete(lines[i]);
        Obj_Delete(circle);

        function<int> CreateLine(real xPos_, real yPos_) {
            int line = InitPrim2D(PRIMITIVE_LINELIST, 2, RP_STG_EFF_SPELL);
            ObjPrim_SetVertexPosition(line, 0, xPos_, yPos_, 1);
            ObjPrim_SetVertexPosition(line, 1, xPos_, yPos_, 1);
            ObjPrim_SetVertexColor(line, 0, 0, 0, 0);
            ObjPrim_SetVertexColor(line, 1, 0, 0, 0);
            return line;
        }

        function<int> CreateCircle(real xPos_, real yPos_) {
            int circle = ObjSpell_Create();
            ObjPrim_SetPrimitiveType(circle, PRIMITIVE_TRIANGLEFAN);
            ObjSpell_SetDamage(circle, 5);
            ObjSpell_SetEraseShot(circle, false);
            ObjPrim_SetVertexCount(circle, 34);
            Obj_SetRenderPriorityI(circle, RP_STG_EFF_SPELL);
            ObjPrim_SetVertexPosition(circle, 0, xPos_, yPos_, 1);
            ascent (i in 0..34) ObjPrim_SetVertexColor(circle, i, COLOR_YELLOW_D);
            ObjSpell_Regist(circle);
            return circle;
        }
    }
}