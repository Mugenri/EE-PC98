//STG window display setup library
#include "./../../lib/lib_HighScore.dnh"

int _displayList; //UI display numbers/icons
int _scoreBonusList; //Spell bonus/cancel bonus numbers on spell banner
bool _bonusIsReady = false; //used to sync the appearance of the spell bonus/cancel bonus effects
bool _bonusDisplaying = false; //spell bonus banner is currently running (used to delay high score notification)

//----------------------------------------------------
//Initialize Display
//----------------------------------------------------
function<void> Display_Init() {
    _displayList = InitParticleList(IMG_SYSTEM_UI, RP_UI_TEXT, 0, 0, 16, 16);
    ParticleListShader(_displayList, 16/256, 16/512);
    ObjSprite2D_SetDestRect(_displayList, 0, 0, 16, 16);
    _scoreBonusList = InitParticleList(IMG_SYSTEM_UI, RP_STG_MAX, 0, 0, 16, 16);
    ParticleListShader(_scoreBonusList, 16/256, 16/512);
    ObjSprite2D_SetDestRect(_scoreBonusList, 0, 0, 16, 16);
    TIntro();   
    Difficulty();
    THighScore();
    TScore();
    TBossLife();
    TBossTimer();
    TPlayerLife();
    TPlayerSpell();
    TGraze();
    TPointItem();
    if (!IsReplay()) TFPS();
    else TReplayFPS();
}

//----------------------------------------------------
//STG Frame Display
//----------------------------------------------------
function<void> InitFrame() {
    int obj = ObjPrim_Create(OBJ_SPRITE_LIST_2D);
    ObjPrim_SetTexture(obj, IMG_SYSTEM_FRAME);
    Obj_SetRenderPriorityI(obj, RP_UI_BG);
    //left
    ObjSpriteList2D_SetSourceRect(obj, 0, 32, 32, 432);
    ObjSpriteList2D_SetDestRect(obj, 0, 0, 32, 400);
    ObjRender_SetPosition(obj, 0, 0, 1);
    ObjSpriteList2D_AddVertex(obj);
    //top
    ObjSpriteList2D_SetSourceRect(obj, 0, 0, 384, 16);
    ObjSpriteList2D_SetDestRect(obj, 0, 0, 384, 16);
    ObjRender_SetPosition(obj, 32, 0, 1);
    ObjSpriteList2D_AddVertex(obj);
    //right
    ObjSpriteList2D_SetSourceRect(obj, 32, 32, 256, 432);
    ObjSpriteList2D_SetDestRect(obj, 0, 0, 224, 400);
    ObjRender_SetPosition(obj, 416, 0, 1);
    ObjSpriteList2D_AddVertex(obj);
    //bottom
    ObjSpriteList2D_SetSourceRect(obj, 0, 16, 384, 32);
    ObjSpriteList2D_SetDestRect(obj, 0, 0, 384, 16);
    ObjRender_SetPosition(obj, 32, 384, 1);
    ObjSpriteList2D_AddVertex(obj);

    ObjSpriteList2D_CloseVertex(obj);

    SetStgFrame(32, 16, 416, 384, RP_STG_MIN, RP_STG_MAX);
}

//----------------------------------------------------
//Stage Fade in
//----------------------------------------------------
task TIntro() {
    int objBG = InitSprite2D(0, 0, MAX_X, MAX_Y, RP_STG_MAX); //black rectangle so the particle list doesn't have to be processed before it's animating
    ObjRender_SetColor(objBG, COLOR_BLACK);

    //Fade square particle list
    int objFade = InitParticleList(IMG_SYSTEM_UI, RP_STG_MAX, 0, 256, 16, 272);
    ObjParticleList_SetColor(objFade, COLOR_BLACK);

    int frames = 8; //number of animation frames

    int objLogo = InitSprite2D(0, 0, 323, 108, IMG_SYSTEM_LOGO, RP_STG_MAX);
    ObjSprite2D_SetDestCenter(objLogo);
    ObjRender_SetPosition(objLogo, 192, 184, 1); //MID_Y constant doesnt work here for some reason, don't care enough to figure out why
    ObjRender_SetAlpha(objLogo, 0);

    //Stop player movement while screen is black
    SetForbidPlayerShot(true);
    SetForbidPlayerSpell(true);
    real[] tempSpeed = GetPlayerSpeed();
    SetPlayerSpeed(0, 0);

    wait(60);

    ascent (i in 1..4) {
        real alpha = 255/3 * i;
        ObjRender_SetAlpha(objLogo, alpha);
        wait(10);
    }
    wait(60);
    ascent (i in 1..4) {
        real alpha = 255 - (255/3 * i);
        ObjRender_SetAlpha(objLogo, alpha);
        wait(10);
    }
    Obj_Delete(objLogo);

    wait(10);

    //Transition begin event
    NotifyEvent(GetAreaCommonData(AREA_STAGE, "SCRIPT_STAGE", -1), EV_STAGE_INTRO_START, 0);

    //resume player movement when the transition begins
    SetForbidPlayerShot(false);
    SetForbidPlayerSpell(false);
    SetPlayerSpeed(tempSpeed[0], tempSpeed[1]);

    //delete black rectangle
    Obj_Delete(objBG);

    //intro animation (80 frames)
    int frame = 0;
    loop (frames) {
        ObjSprite2D_SetSourceRect(objFade, 112 - (frame * 16), 256, 128 - (frame * 16), 272); //animation is drawn right to left in the file
        ObjSprite2D_SetDestRect(objFade, 0, 0, 16, 16);
        loop (10) { //number of frames to hold each animation frame
            AddParticles();
            yield;
        }
        frame++;
    }
    
    Obj_Delete(objFade);

    NotifyEvent(GetAreaCommonData(AREA_STAGE, "SCRIPT_STAGE"), EV_STAGE_START, 0); //used by stage script to start plurals/dialogue

    function<void> AddParticles() { //creates matrix of black squares
        int x = 0;
        int y = 0;
        loop (23) { //vertical
            loop (24) { //horizontal
                ObjParticleList_SetPosition(objFade, x, y, 1);
                ObjParticleList_AddInstance(objFade);
                x += 16;
            }
            x = 0;
            y += 16;
        }
    }
}

//----------------------------------------------------
//Selected Difficulty Display
//----------------------------------------------------
function<void> Difficulty() {
    string[] texts = ["Easy", "Normal", "Hard", "Unreal", "Extra", "Ab-Ex"];
    int[] colors = [COLOR_WHITE, COLOR_WHITE, COLOR_WHITE, COLOR_WHITE, COLOR_RED, COLOR_WHITE];
    int diff = GetAreaCommonData(AREA_TITLE, "Difficulty", 0);
    int objText = ObjText_Create();
	ObjText_SetText(objText, texts[diff]);
	ObjText_SetFontSize(objText, 16);
    ObjText_SetFontType(objText, HEADER_FONT);
	ObjText_SetVertexColor(objText, 0xFF000000 + colors[diff]);
	ObjText_SetFontBorderType(objText, BORDER_NONE);
	Obj_SetRenderPriorityI(objText, RP_UI_TEXT);
	ObjRender_SetPosition(objText, 448, 20, 1);
    ObjText_SetMaxWidth(objText, 128);
    ObjText_SetHorizontalAlignment(objText, ALIGNMENT_CENTER);
}

//----------------------------------------------------
//High Score Display
//----------------------------------------------------
task THighScore() {
	//High Score Text
    int objScore = InitSprite2D(0, 272, 53, 288, IMG_SYSTEM_UI, RP_UI_TEXT);
    ObjRender_SetColor(objScore, COLOR_YELLOW);
    ObjRender_SetPosition(objScore, 486, 48, 1);

	// Digits
	int count = 8;
    int scoreRender = 0;
    //scores and continues
    int score = GetScore();
    int highScore = HS_GetHighScore();
    int continues = 0;
    
    int[] numList;
    bool newHS = false;
    
    loop {
        score = GetScore();
        highScore = HS_GetHighScore();
        
        if (score < highScore) { //high score > score OR continues have been used. render high score as-is
            continues = GetAreaCommonData(AREA_STAGE, "Continues", 0);
            numList = DigitToArray(highScore, count);
            while (score < highScore || continues != 0) {
                score = GetScore();
                for (int i = 0; i < count; i++) {
                    ObjParticleList_SetPosition(_displayList, 448 + i * 16, 64, 1);
                    ObjParticleList_SetExtraData(_displayList, numList[i], 1, 0);
                    ObjParticleList_AddInstance(_displayList);
                }
                yield;   
            }
            newHS = true; //GetScore() became higher than highScore, new high score
        } else { //score >= highscore, render current score
            if (newHS && continues == 0) TNewHighScore();
            while (continues != 0 || score > highScore) {
                score = GetScore();
                numList = DigitToArray(scoreRender, count);
                //Gradual increase of score counter
                if (scoreRender < score) {
                    scoreRender += round((score - scoreRender)/10);
                    scoreRender -= scoreRender % 10; //take off the last number
                    scoreRender += continues; //add number of continues to the end of the number
                    if (score - scoreRender <= 10) scoreRender = score;
                }
                //render particle
                for (int i = 0; i < count; i++) {
                    ObjParticleList_SetPosition(_displayList, 448 + i * 16, 64, 1);
                    ObjParticleList_SetExtraData(_displayList, numList[i], 1, 0);
                    ObjParticleList_AddInstance(_displayList);
                }
                yield;
            }
        }
    }

    task TNewHighScore() { //new high score notification
        while (_bonusDisplaying) yield; //wait for bonus text to finish its animation
        newHS = false;
        CallSFX(SND_EXTEND);
        //Spell Bonus Text
        int objText = InitSprite2D(0, 416, 128, 432, IMG_SYSTEM_UI, RP_STG_MAX);
        ObjRender_SetY(objText, 32);

        //move text
        for (int i = 39; i >= 0; i--) { 
            if (_bonusDisplaying) break;
            ObjRender_SetX(objText, (MID_X + i * 8) - 64);
            yield;
        }
        //hold position
        loop (60) {
            if (_bonusDisplaying) break;
            yield;
        }
        //move text
        for (int i = 0; i < 40; i++) {
            if (_bonusDisplaying) break;
            ObjRender_SetX(objText, (MID_X - i * 8) - 64);
            yield;
        }
        Obj_Delete(objText);
    }
}

//----------------------------------------------------
//Score Display
//----------------------------------------------------
task TScore() { //TODO add support for scores > 100_000_000
	//Score Text
    int objScore = InitSprite2D(16, 272, 53, 288, IMG_SYSTEM_UI, RP_UI_TEXT);
    ObjRender_SetColor(objScore, COLOR_YELLOW);
    ObjRender_SetPosition(objScore, 493, 80, 1);

	// Digits
	int count = 8;
    int scoreRender = 0;
    int continues = GetAreaCommonData(AREA_STAGE, "Continues", 0);
    loop {
        int score = GetScore();
		score = min(score, 99999999);
		int[] numList = DigitToArray(scoreRender, count);

        //Gradual increase of score counter
        if (scoreRender < score) {
            scoreRender += round((score - scoreRender)/10);
            scoreRender -= scoreRender % 10; //take off the last number
            scoreRender += continues; //add number of continues to the end of the number
            if (score - scoreRender <= 10) scoreRender = score;
        } else if (scoreRender > score) { //score decreased through use of continues
            scoreRender = score; 
            continues = GetAreaCommonData(AREA_STAGE, "Continues", 0);
        }
        //render particle
        for (int i = 0; i < count; i++) {
            ObjParticleList_SetPosition(_displayList, 448 + i * 16, 96, 1);
            ObjParticleList_SetExtraData(_displayList, numList[i], 1, 0);
            ObjParticleList_AddInstance(_displayList);
        }
        yield;
    }
}

//----------------------------------------------------
//Bosss Life Display
//----------------------------------------------------
task TBossLife() {
    //Enemy!! text
    int objText = InitSprite2D(0, 288, 48, 304, IMG_SYSTEM_UI, RP_UI_TEXT);
    ObjRender_SetColor(objText, COLOR_YELLOW);
    ObjRender_SetPosition(objText, 456, 129, 1);
    Obj_SetVisible(objText, false);

    //Lifebar
    int objLife = InitPrim2D(PRIMITIVE_TRIANGLESTRIP, 4, RP_UI_TEXT);
    ObjRender_SetPosition(objLife, 448, 148, 1);

    //Lifebar underline
    int objLine = InitPrim2D(PRIMITIVE_LINESTRIP, 2, RP_UI_TEXT);
    ObjRender_SetPosition(objLine, 448, 156, 1);
    ObjPrim_SetVertexPosition(objLine, 0, 0, 0, 1);
    ObjPrim_SetVertexPosition(objLine, 1, 128, 0, 1);
    Obj_SetVisible(objLine, false);

    //lifebar heart icon
    int objIcon = InitSprite2D(52, 339, 62, 348, IMG_SYSTEM_UI, RP_UI_TEXT);
    ObjRender_SetPosition(objIcon, 567, 147, 1);
    Obj_SetVisible(objIcon, false);

    //Max Life Text
    int objMax = InitSprite2D(0, 336, 52, 349, IMG_SYSTEM_UI, RP_UI_TEXT);
    ObjRender_SetPosition(objMax, 526, 144, 1);
    Obj_SetVisible(objMax, false);

	int lastRemStep = -1;
	real lifeRateRender = 0;

	loop {
		if (_objScene != ID_INVALID) RenderLife();
		yield;
	}


	function<void> RenderLife() {
        int[] bossID = GetEnemyBossObjectID();
        if (length(bossID) == 0) return;

		//Remaining Steps
		int countRemStep = ObjEnemyBossScene_GetInfo(_objScene, INFO_REMAIN_STEP_COUNT);
		if (lastRemStep != countRemStep) {
			//Step Change, refill boss bar
			lifeRateRender = 0;
		}

        //Remaining Step Display
        if (countRemStep > 4) {
            //icon
            ObjParticleList_SetPosition(_displayList, 512, 128, 1);
            ObjParticleList_SetExtraData(_displayList, 9, 17, 0);
            ObjParticleList_SetColor(_displayList, COLOR_INDIGO_L);
            ObjParticleList_AddInstance(_displayList);
            ObjParticleList_SetColor(_displayList, COLOR_WHITE);
            //x
            ObjParticleList_SetPosition(_displayList, 528, 128, 1);
            ObjParticleList_SetExtraData(_displayList, 10, 0, 0);
            ObjParticleList_AddInstance(_displayList);
            //num
            int tempStep = clamp(countRemStep, 0, 9);
            ObjParticleList_SetPosition(_displayList, 560, 128, 1);
            ObjParticleList_SetExtraData(_displayList, tempStep, 1, 0);
            ObjParticleList_AddInstance(_displayList);
        } else {
            for (int i = 0; i < countRemStep; i++) {
                ObjParticleList_SetPosition(_displayList, 496 + 4 * 16 - i * 16, 128, 1);
                ObjParticleList_SetExtraData(_displayList, 9, 17, 0);
                ObjParticleList_SetColor(_displayList, COLOR_INDIGO_L);
                ObjParticleList_AddInstance(_displayList);
                ObjParticleList_SetColor(_displayList, COLOR_WHITE);
            }
        }

		//Life Display
		real lifeTotalMax = ObjEnemyBossScene_GetInfo(_objScene, INFO_ACTIVE_STEP_TOTAL_MAX_LIFE); //step max health
		real lifeTotal = round(ObjEnemyBossScene_GetInfo(_objScene, INFO_ACTIVE_STEP_TOTAL_LIFE)); //step current health (rounded because of how invincibility is handled)
		real lifeRatio = min(lifeTotal / lifeTotalMax, lifeRateRender); //display the lower of the two
		ObjPrim_SetVertexPosition(objLife, 0, 0, 0, 1);
        ObjPrim_SetVertexPosition(objLife, 1, 0, 8, 1);
        ObjPrim_SetVertexPosition(objLife, 2, 128 * lifeRatio, 0, 1);
        ObjPrim_SetVertexPosition(objLife, 3, 128 * lifeRatio, 8, 1);

        //Max Text
        Obj_SetVisible(objMax, lifeRatio >= 1);

        //Life Color
        int color = COLOR_WHITE;
        if (lifeRatio <= 0.25) color = COLOR_RED;
        else if (lifeRatio <= 0.5) color = COLOR_MAGENTA_L;
        else if (lifeRatio <= 0.75) color = COLOR_TEAL;
        else if (lifeRatio < 1) color = COLOR_YELLOW;

        ascent (i in 0..4) ObjPrim_SetVertexColor(objLife, i, color);
        ascent (i in 0..2) ObjPrim_SetVertexColor(objLine, i, color);
        ObjRender_SetColor(objIcon, color);

        //attempt to increase health render bar until it reaches max
		lifeRateRender += 0.01;
		lifeRateRender = min(lifeRateRender, 1);
		lastRemStep = countRemStep;

        //if no boss present, hide Enemy!! text and life underline
        bool visible = lifeTotal > 0 || countRemStep != 0;
        Obj_SetVisible(objText, visible);
        Obj_SetVisible(objLine, visible);
        Obj_SetVisible(objIcon, visible);
	}
}

//----------------------------------------------------
//Timer Display
//----------------------------------------------------
task TBossTimer() {
    int obj = InitPrim2D(PRIMITIVE_LINESTRIP, 2, RP_UI_TEXT); //timer line
    ObjRender_SetPosition(obj, 448, 162, 1);

    int icon = InitSprite2D(192, 336, 199, 343, IMG_SYSTEM_UI, RP_UI_TEXT);
    ObjRender_SetPosition(icon, 572, 158, 0);
    Obj_SetVisible(icon, false);

	loop {
		if (_objScene != ID_INVALID) RenderTimer();
		yield;
	}

	function<void> RenderTimer() {
		real timer = ObjEnemyBossScene_GetInfo(_objScene, INFO_TIMERF);
        real timerTotal = ObjEnemyBossScene_GetInfo(_objScene, INFO_ORGTIMERF);
        int bossLife = ObjEnemyBossScene_GetInfo(_objScene, INFO_CURRENT_LIFE);

        int timerColor = timer <= 600 ? COLOR_RED : COLOR_WHITE;

        if (bossLife <= 0) timer = 0;

        ObjPrim_SetVertexPosition(obj, 0, 0, 0, 1);
        ObjPrim_SetVertexPosition(obj, 1, 128 * (timer/timerTotal) , 0, 1);
        ObjPrim_SetVertexColor(obj, 0, timerColor);
        ObjPrim_SetVertexColor(obj, 1, timerColor);

        //icon stuff
        ObjRender_SetPosition(icon, 445 + 128 * (timer/timerTotal), 158, 0);
        Obj_SetVisible(icon, timer > 0);
        ObjRender_SetColor(icon, timerColor);

        //sound
        if (timerColor == COLOR_RED && timer % 60 == 0 && bossLife > 0) { //timer <= 10 seconds every second if boss alive
            CallSFX(SND_TIMER);
        }
	}
}

//----------------------------------------------------
//Player Lives Display
//----------------------------------------------------
task TPlayerLife() {
	//life Text
    int objText = InitSprite2D(0, 306, 32, 320, IMG_SYSTEM_UI, RP_UI_TEXT);
    ObjRender_SetColor(objText, COLOR_YELLOW);
    ObjRender_SetPosition(objText, 456, 178, 1);

    loop {
        int lives = GetPlayerLife();
        lives = clamp(lives, 0, 9);

        if (lives > 5) {
            //icon
            ObjParticleList_SetPosition(_displayList, 512, 177, 1);
            ObjParticleList_SetExtraData(_displayList, 8, 17, 0);
            ObjParticleList_SetColor(_displayList, COLOR_RED_L);
            ObjParticleList_AddInstance(_displayList);
            ObjParticleList_SetColor(_displayList, COLOR_WHITE);
            //x
            ObjParticleList_SetPosition(_displayList, 528, 177, 1);
            ObjParticleList_SetExtraData(_displayList, 10, 0, 0);
            ObjParticleList_AddInstance(_displayList);
            //num
            ObjParticleList_SetPosition(_displayList, 560, 177, 1);
            ObjParticleList_SetExtraData(_displayList, lives, 1, 0);
            ObjParticleList_AddInstance(_displayList);
        } else {
            //icons
            for (int i = 0; i < lives; i++) {
                ObjParticleList_SetPosition(_displayList, 496 + i * 16, 177, 1);
                ObjParticleList_SetExtraData(_displayList, 8, 17, 0);
                ObjParticleList_SetColor(_displayList, COLOR_RED_L);
                ObjParticleList_AddInstance(_displayList);
                ObjParticleList_SetColor(_displayList, COLOR_WHITE);
            }
        }
        yield;
    }
}

//----------------------------------------------------
//Player Spell Display
//----------------------------------------------------
task TPlayerSpell() {
	//Spell Text
    int objText = InitSprite2D(0, 322, 31, 335, IMG_SYSTEM_UI, RP_UI_TEXT);
    ObjRender_SetColor(objText, COLOR_YELLOW);
    ObjRender_SetPosition(objText, 456, 210, 1);

	loop {
        int spell = GetPlayerSpell();
        spell = clamp(spell, 0, 9);

        if (spell > 5) {
            //icon
            ObjParticleList_SetPosition(_displayList, 512, 209, 1);
            ObjParticleList_SetExtraData(_displayList, 7, 17, 0);
            ObjParticleList_SetColor(_displayList, COLOR_GREEN);
            ObjParticleList_AddInstance(_displayList);
            ObjParticleList_SetColor(_displayList, COLOR_WHITE);
            //x
            ObjParticleList_SetPosition(_displayList, 528, 209, 1);
            ObjParticleList_SetExtraData(_displayList, 10, 0, 0);
            ObjParticleList_AddInstance(_displayList);
            //num
            ObjParticleList_SetPosition(_displayList, 560, 209, 1);
            ObjParticleList_SetExtraData(_displayList, spell, 1, 0);
            ObjParticleList_AddInstance(_displayList);
        } else {
            //icons
            for (int i = 0; i < spell; i++) {
                ObjParticleList_SetPosition(_displayList, 496 + i * 16, 209, 1);
                ObjParticleList_SetExtraData(_displayList, 7, 17, 0);
                ObjParticleList_SetColor(_displayList, COLOR_GREEN);
                ObjParticleList_AddInstance(_displayList);
                ObjParticleList_SetColor(_displayList, COLOR_WHITE);
            }
        }
        yield;
    }
}

//----------------------------------------------------
//Graze Display
//----------------------------------------------------
task TGraze() {
	//Graze Text
    int objGraze = InitSprite2D(64, 289, 96, 304, IMG_SYSTEM_UI, RP_UI_TEXT);
    ObjRender_SetColor(objGraze, COLOR_YELLOW);
    ObjRender_SetPosition(objGraze, 456, 242, 1);

	//Digits
	int maxCount = 4;
    loop {
        int graze = GetGraze();
        graze = min(graze, 9999);
        //length of digit
        int numLength = GetDigitLength(graze);
        int[] numList = DigitToArray(graze, min(numLength, maxCount));
        //draws from right to left
        for (int i = 0; i < length(numList); i++) {
            int num = numList[length(numList) - i - 1];
            ObjParticleList_SetPosition(_displayList, 560 - i * 16, 242, 1);
            ObjParticleList_SetExtraData(_displayList, num, 1, 0);
            ObjParticleList_AddInstance(_displayList);
        }
        yield;
    }
}

//----------------------------------------------------
//Point Item Display
//----------------------------------------------------
task TPointItem() {
    int maxCount = 4;
    loop {
        //Icon
        ObjParticleList_SetPosition(_displayList, 464, 267, 1);
        ObjParticleList_SetExtraData(_displayList, 4, 17, 0);
        ObjParticleList_SetColor(_displayList, COLOR_YELLOW);
        ObjParticleList_AddInstance(_displayList);
        ObjParticleList_SetColor(_displayList, COLOR_WHITE);

        //Digits
        int point = GetPoint();
        point = min(point, 999);
        //length of digit
        int numLength = GetDigitLength(point);
        int[] numList = DigitToArray(point, min(numLength, maxCount));
        //draws from right to left
        for (int i = 0; i < length(numList); i++) {
            int num = numList[length(numList) - i - 1];
            ObjParticleList_SetPosition(_displayList, 560 - i * 16, 267, 1);
            ObjParticleList_SetExtraData(_displayList, num, 1, 0);
            ObjParticleList_AddInstance(_displayList);
        }
        yield;
    }
}

//----------------------------------------------------
//Active Spell Banner and Spell History Display
//----------------------------------------------------
task TSpellDisplay(int spellID_) {
    int[] history = Spell_GetHistory(spellID_);
    string name = Spell_GetName(spellID_);
    int seen = history[0];
    int captured = history[1];
    int bonus = NotifyEvent(GetAreaCommonData(AREA_STAGE, "SCRIPT_SINGLE", 0), EV_REQUEST_SPELL_SCORE, 0);
    //if you see an error here you forgot to assign a spell bonus to your spell
    bool spellFailed = false;
    bool visible = true;

    int banner = ObjPrim_Create(OBJ_SPRITE_LIST_2D);
    ObjPrim_SetTexture(banner, IMG_SYSTEM_UI);
    Obj_SetRenderPriorityI(banner, RP_STG_SPELL);
    //graphic
    ObjRender_SetPosition(banner, 0, 0, 1);
    ObjSpriteList2D_SetSourceRect(banner, 0, 480, 208, 512);
    ObjSpriteList2D_SetDestRect(banner, 0, 0, 208, 32);
    ObjSpriteList2D_AddVertex(banner);
    //bonus text
    ObjRender_SetPosition(banner, 24, 19, 1);
    ObjSpriteList2D_SetSourceRect(banner, 160, 344, 192, 352);
    ObjSpriteList2D_SetDestRect(banner, 0, 0, 32, 8);
    ObjSpriteList2D_AddVertex(banner);
    //history text
    ObjRender_SetPosition(banner, 128, 19, 1);
    ObjSpriteList2D_SetSourceRect(banner, 160, 352, 192, 360);
    ObjSpriteList2D_SetDestRect(banner, 0, 0, 32, 8);
    ObjSpriteList2D_AddVertex(banner);

    if (captured < 100) { //not mastered
        ObjRender_SetPosition(banner, 176, 19, 1);
        ObjSpriteList2D_SetSourceRect(banner, 152, 336, 160, 344);
        ObjSpriteList2D_SetDestRect(banner, 0, 0, 8, 8);
        ObjSpriteList2D_AddVertex(banner);

        if (seen > 99) { //99+
            ObjRender_SetPosition(banner, 200, 19, 1);
            ObjSpriteList2D_SetSourceRect(banner, 64, 336, 72, 344);
            ObjSpriteList2D_SetDestRect(banner, 0, 0, 8, 8);
            ObjSpriteList2D_AddVertex(banner);
        }
    } else { //MASTER text
        ObjRender_SetPosition(banner, 160, 19, 1);
        ObjSpriteList2D_SetSourceRect(banner, 160, 360, 208, 368);
        ObjSpriteList2D_SetDestRect(banner, 0, 0, 48, 8);
        ObjSpriteList2D_AddVertex(banner);
    }

    ObjSpriteList2D_CloseVertex(banner);

    int nameText = CreateText(0, 0, RP_STG_SPELL, name, COLOR_WHITE); //spawn off screen just in case of weirdness
    ObjText_SetHorizontalAlignment(nameText, ALIGNMENT_RIGHT);
    ObjText_SetMaxWidth(nameText, 384);

    int failText = InitSprite2D(160, 336, 192, 344, IMG_SYSTEM_UI, RP_STG_SPELL); //bonus failed text
    Obj_SetVisible(failText, false);

    int yPos = -32; //starting position of banner and other objects

    _objScene = GetEnemyBossSceneObjectID(); //update manually, executes same frame as single script

    async { //checks if spell has been failed
        while(ObjEnemyBossScene_GetInfo(_objScene, INFO_CURRENT_LIFE) > 0) { //while spell active
            if (ObjEnemyBossScene_GetInfo(_objScene, INFO_PLAYER_SHOOTDOWN_COUNT) + ObjEnemyBossScene_GetInfo(_objScene, INFO_PLAYER_SPELL_COUNT) > 0) {
                Obj_SetVisible(failText, visible);
                spellFailed = true;
                break;
            }
            yield;
        }
    }

    for (int i = 1; i <= 60; i++) { //entry animation
        yPos = Interpolate_Overshoot(-32, 0, 2, i/60);
        ObjRender_SetPosition(banner, 176, yPos, 1);
        ObjRender_SetPosition(nameText, 0, yPos, 1);
        ObjRender_SetPosition(failText, 232, yPos + 19, 1);
        UpdateAsciiNum(yPos);
        yield;
    }
    while(ObjEnemyBossScene_GetInfo(_objScene, INFO_CURRENT_LIFE) > 0) { //while spell active
        visible = GetPlayerY() > 64;
        Obj_SetVisible(banner, visible);
        Obj_SetVisible(nameText, visible);
        Obj_SetVisible(failText, spellFailed && visible);
        if (visible) UpdateAsciiNum(yPos);
        yield;
    }
    for (int i = 1; i <= 60; i++) { //exit animation
        yPos = Interpolate_Accelerate(0, -32, i/60);
        ObjRender_SetPosition(banner, 176, yPos, 1);
        ObjRender_SetPosition(nameText, 0, yPos, 1);
        ObjRender_SetPosition(failText, 232, yPos + 19, 1);
        if (visible) UpdateAsciiNum(yPos);
        yield;
    }

    Obj_Delete(banner);
    Obj_Delete(nameText);
    Obj_Delete(failText);

    function<void> UpdateAsciiNum(real yPos_) {
        if (!spellFailed) Ascii_SpellNum(232, yPos_ + 19, bonus); //Bonus number
        //captured
        if (captured < 100) {
            Ascii_SpellNum(336, yPos_ + 19, captured);
            //seen
            Ascii_SpellNum(360, yPos_ + 19, min(seen, 99)); //cap to 99
        } //else spell has been mastered, render no numbers
    }
}

//----------------------------------------------------
//Spell Bonus Display
//----------------------------------------------------
task TSpellBonus(int score_) {
    while (!_bonusIsReady) yield; //has to yield until bonusReady for multiple things (ascii score text position esp.)
    _bonusIsReady = false; 
    _bonusDisplaying = true;
    AddScore(score_);
    //Ascii numbers around boss
    int tempScore = score_;
    real[] pos = GetAreaCommonData(AREA_STAGE, "Pos_Bonus", [0, 0]);
    while (tempScore > 10000) {
        Ascii_ScoreNum(pos[0] + prand_int(-64, 64), pos[1] + prand_int(-64, 64), 10000, COLOR_YELLOW);
        tempScore -= 10000;
    }
    if (tempScore > 0) Ascii_ScoreNum(pos[0] + prand_int(-64, 64), pos[1] + prand_int(-64, 64), tempScore, COLOR_YELLOW);

    //Spell Bonus Text
    int objText = InitSprite2D(39, 368, 148, 384, IMG_SYSTEM_UI, RP_STG_MAX);
    ObjRender_SetY(objText, 32);

    //get length of score number
    int numLength = GetDigitLength(score_);
    int[] numList = DigitToArray(score_, min(numLength, 9));

    //move text
    for (int i = 39; i >= 0; i--) { 
        ObjRender_SetX(objText, (97 + i * 8) - 47); //align with cancel bonus text
        yield;
    }
    //hold position
    loop (120) {
        UpdateList(304);
        yield;
    }
    //move text
    for (int i = 0; i < 40; i++) {
        ObjRender_SetX(objText, (97 - i * 8) - 47);
        UpdateList(304 + i * 8);
        yield;
    }
    Obj_Delete(objText);
    _bonusDisplaying = false;

    function<void> UpdateList(int x_) {
        //draws from right to left
        for (int i = 0; i < length(numList); i++) {
            int num = numList[length(numList) - i - 1];
            ObjParticleList_SetPosition(_scoreBonusList, x_ - i * 16, 32, 1);
            ObjParticleList_SetExtraData(_scoreBonusList, num, 1, 0);
            ObjParticleList_AddInstance(_scoreBonusList);
        }
    }
}

//----------------------------------------------------
//Bullet Cancel Score Total Display
//----------------------------------------------------
task TCancelBonus(int score_) {
    _bonusIsReady = true;
    if (ObjEnemyBossScene_GetInfo(_objScene, INFO_IS_DURABLE_SPELL) && score_ != -1) return; //no shot cancel bonus on survival spells (still need bonus fail text)
    //Bonus!! Text
    int objText = InitSprite2D(65, 352, 127, 368, IMG_SYSTEM_UI, RP_STG_MAX);
    ObjRender_SetY(objText, 16);
    //Bonus fail text & no score
    if (score_ == -1) {
        ObjSprite2D_SetSourceRect(objText, 0, 384, 127, 400);
        ObjSprite2D_SetDestRect(objText, 0, 0, 127, 16);
    }
    
    //get length of score number
    int numLength = score_ == -1 ? 0 : GetDigitLength(score_);
    int[] numList = [];
    if (numLength > 0) numList = DigitToArray(score_, min(numLength, 9));

    //move text
    for (int i = 39; i >= 0; i--) { 
        ObjRender_SetX(objText, 97 + i * 8);
        yield;
    }
    //hold position
    loop (120) {
        UpdateList(304);
        yield;
    }
    //move text
    for (int i = 0; i < 40; i++) {
        ObjRender_SetX(objText, 97 - i * 8);
        UpdateList(304 + i * 8);
        yield;
    }
    Obj_Delete(objText);

    function<void> UpdateList(int x_) {
        //draws from right to left
        for (int i = 0; i < length(numList); i++) {
            int num = numList[length(numList) - i - 1];
            ObjParticleList_SetPosition(_scoreBonusList, x_ - i * 16, 16, 1);
            ObjParticleList_SetExtraData(_scoreBonusList, num, 1, 0);
            ObjParticleList_AddInstance(_scoreBonusList);
        }
    }
}

//----------------------------------------------------
//FPS Display
//----------------------------------------------------
task TFPS() {
	int objText = ObjText_Create();
	ObjText_SetFontSize(objText, 16);
	ObjText_SetFontType(objText, SYS_FONT);
	ObjText_SetVertexColor(objText, 0xFF000000 + COLOR_WHITE);
	ObjText_SetHorizontalAlignment(objText, ALIGNMENT_RIGHT);
	ObjText_SetMaxWidth(objText, GetScreenWidth() - 8);
	Obj_SetRenderPriorityI(objText, RP_UI_MAX);
	ObjRender_SetX(objText, 0);
	ObjRender_SetY(objText, GetScreenHeight() - 20);

	loop {
		real fps = GetCurrentFps();
		string text = vtos("1.2f", fps) ~ "fps";
		ObjText_SetText(objText, text);
		yield;
	}
}

task TReplayFPS() {
	if (!IsReplay()) return;

	int objText = ObjText_Create();
	ObjText_SetFontSize(objText, 12);
	ObjText_SetFontBold(objText, true);
	ObjText_SetVertexColor(objText, 0xFF000000 + COLOR_WHITE);
	ObjText_SetFontBorderType(objText, BORDER_FULL);
	ObjText_SetFontBorderColor(objText, 255, 255, 255);
	ObjText_SetFontBorderWidth(objText, 1);
	Obj_SetRenderPriorityI(objText, RP_UI_MAX);

	int px = GetStgFrameLeft() + GetStgFrameWidth() - 18;
	int py = GetStgFrameTop() + GetScreenHeight() - 14;
	ObjRender_SetX(objText, px);
	ObjRender_SetY(objText, py);

	loop {
		real fps = GetReplayFps();
		string text = vtos("02d", fps);
		ObjText_SetText(objText, text);
		yield;
	}
}

//----------------------------------------------------
//Utility
//----------------------------------------------------
function<void> NotificationText(int type_) { //runs a notification across the top of the screen

}