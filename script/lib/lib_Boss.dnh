//Boss common functions library, includes all libraries in /bosslib
#include "./lib_Common.dnh"
#include "./lib_Shot.dnh"
#include "./lib_Effect.dnh"
#include "./lib_Item.dnh"
#include "./lib_Spell.dnh"

#include "./bosslib/lib_Character.dnh"
#include "./bosslib/lib_BossUtil.dnh"

bool _bossAlive = true; //boss health > 0
bool _isDamaged = false; //used for damage animation
bool _isSpellVulnerable = true; //is vulnerable to bomb damage
bool _spellBarrier = false; //is spell barrier active

bool _isSurvival = false; //survival spell

real _bossLife; //current life
real _previousLife = 0; //life of previous frame

real intersectionShot = 32; //default intersection to shot
real intersectionPlayer = 24; //default intersection to player

function<void> Boss_Init(bool isVulnerable_) { //Initialize a boss scene
    SetAreaCommonData(AREA_STAGE, "SCRIPT_SINGLE", GetOwnScriptID());
    InitCommon();
    InitEffectParticle();

    _isSpellVulnerable = isVulnerable_;

    //if spell practice, set variables (drop no items)
    //else ?
    _isSurvival = ObjEnemyBossScene_GetInfo(_objScene, INFO_IS_DURABLE_SPELL);

    if (_isSurvival) _isSpellVulnerable = false; //just in case

    LoadShotData();
}

function<int> Boss_Create(string bossID_) { //Initialize a boss object
    int objBoss = ObjEnemy_Create(OBJ_ENEMY_BOSS);
    Boss_SetID(objBoss, bossID_);
    Boss_GetInitPosition(objBoss);
    Boss_SetVulnerable(objBoss, false); //Must set damage rate manually after transition effects
    Boss_SetIndicator(objBoss);
    ObjEnemy_Regist(objBoss);
    return objBoss;
}

function<void> Boss_Update(int mainBoss_) { //update function to be run in mainloop of single (mainBoss_ is the primary boss object for multiple boss fights)
    _isDamaged = false;
    _bossLife = ObjEnemy_GetInfo(mainBoss_, INFO_LIFE);

    if (_bossLife <= 0) {
        _bossAlive = false; //health check
        return;
    }

    if (_bossLife < _previousLife) { //damage check
        if (_previousLife - _bossLife > 0.01 && !_isSurvival) { //if the boss has lost more than a hundredth of a point of health from the last frame
            CallSFX(SND_DAMAGE);
            _isDamaged = true;
            AddScore(10 * (round (_previousLife - _bossLife))); //~10 points per point of boss health
        } else {
            CallSFX(SND_INVINCIBLE);
            ObjEnemy_SetLife(mainBoss_, ceil(_bossLife)); //accounts for how invincibility is handled
        }
    }

    if (!_isSpellVulnerable && !_isSurvival && _spellBarrier == false && IsPlayerSpellActive() && _bossAlive) TSpellBarrier(mainBoss_); //bomb invulnerability check

    _previousLife = _bossLife;

    task TSpellBarrier(int mainBoss_) {
        _spellBarrier = true;
        while (IsPlayerSpellActive() && _bossAlive) { //_bossAlive just in case
            Boss_SetVulnerable(mainBoss_, false);
            yield;
        }
        wait(15);
        Boss_SetVulnerable(mainBoss_, true);
        _spellBarrier = false;
    }
}

//Call at the end of a single
task Boss_Finalize(int obj_) {
    real xPos = ObjMove_GetX(obj_);
    real yPos = ObjMove_GetY(obj_);
    SetAreaCommonData(AREA_STAGE, "Pos_Bonus", [xPos, yPos]); //Spell bonus yellow ascii text position

    bool isSpell = ObjEnemyBossScene_GetInfo(_objScene, INFO_IS_SPELL);
    bool isFinal = ObjEnemyBossScene_GetInfo(_objScene, INFO_IS_LAST_STEP);
    bool isCapture = Boss_IsSpellCaptured();

    if (isFinal) {
        SetPlayerInvincibilityFrame(60);
        Particle_RandomExplosionBig(xPos, yPos); //this function is blocking
        Obj_SetVisible(obj_, false);
        StartSlow(TARGET_ALL, 30);
    } else {
        Particle_RandomExplosionSmall(xPos, yPos);
    }

    //Items and Bullet Cancel score values (only for spell cards)
    int scoreTotal = 0;
    if (isCapture && isSpell && !_isSurvival) { //spell capture on non-survival spells
        int score = 10;
        int scoreBonus = 10;
        int numBullets = 0;
        real radius = 200;
        loop (5) {
            for each (shot in GetShotIdInCircleA2(MID_X, MID_Y - GetStgFrameHeight() / 2, radius, TARGET_ENEMY)) {
                if (ObjMove_GetX(shot) < -16 || ObjMove_GetX(shot) > GetStgFrameWidth() + 16 || ObjMove_GetY(shot) < -16 || ObjMove_GetY(shot) > GetStgFrameHeight() + 16) {
                    continue; //no items spawn off screen
                } else if (radius == 600) { //assign shot score bonus, only runs on final loop
                    Obj_SetValueI(shot, SHOT_SCORE, score);
                    scoreTotal += score;
                    score += scoreBonus;
                    scoreBonus += 10;
                    score = clamp(score, 0, 12800);
                }
                if (numBullets < 40 && Obj_GetType(shot) == OBJ_SHOT && rand_int(1, 4) == 1) { //random <= 40 bullets drop point items
                    Obj_SetValueI(shot, SHOT_DROP_ITEM, true);
                    numBullets++;
                }
            }
            radius += 100;
        }
    } else if (!isCapture && isSpell) { //if capture is failed on any type of spell
        scoreTotal = -1;
    } //scoreTotal remains 0 otherwise

    DeleteShotAll(TYPE_ALL, TYPE_ITEM); //Delete to item for score text

    if (isSpell) NotifyEvent(GetAreaCommonData(AREA_SYSTEM, "SCRIPT_SYSTEM", 0), EV_CANCEL_BONUS, scoreTotal); //Shot cancel bonus text
    wait(64); //explosion time
    StopSlow(TARGET_ALL); //if slow is active
    wait(60); //grace period

    //Setup boss init position for next single
    xPos = ObjMove_GetX(obj_);
    yPos = ObjMove_GetY(obj_);
    Boss_SetInitPosition(obj_, xPos, yPos);
    Obj_Delete(obj_);
    
    //Close script
    SetAutoDeleteObject(true);
    CloseScript(GetOwnScriptID());
}