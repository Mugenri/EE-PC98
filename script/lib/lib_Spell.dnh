//spell name & history library
//Formatted SpellSeen/Captured_GAMEMODE_PLAYERTYPE_STAGE_SPELL

//Spell history
function<void> Spell_Seen(int stageIndex_, int spellID_) {
    if (IsReplay()) return;
    int gameMode = GetGameMode();
    int player = GetPlayerType();
    int[] history = Spell_GetHistory(gameMode, player, stageIndex_, spellID_);
    SetAreaCommonData(AREA_SAVE, "SpellSeen_" ~ IntToString(gameMode) ~ "_" ~ IntToString(player) ~ "_" ~ IntToString(stageIndex_) ~ "_" ~ IntToString(spellID_), history[0] + 1);
}
function<void> Spell_Captured(int stageIndex_, int spellID_) {
    if (IsReplay()) return;
    int gameMode = GetGameMode();
    int player = GetPlayerType();
    int[] history = Spell_GetHistory(gameMode, player, stageIndex_, spellID_);
    SetAreaCommonData(AREA_SAVE, "SpellCaptured_" ~ IntToString(gameMode) ~ "_" ~ IntToString(player) ~ "_" ~ IntToString(stageIndex_) ~ "_" ~ IntToString(spellID_), history[1] + 1);
}
function<int[]> Spell_GetHistory(int gameMode_, int playerID_, int stageIndex_, int spellID_) {
    assert(spellID_ >= 0, IntToString(spellID_) ~ " is an invalid spell ID.");
    int[] history = [];
    history = history ~ [GetAreaCommonData(AREA_SAVE, "SpellSeen_" ~ IntToString(gameMode_) ~ "_" ~ IntToString(playerID_) ~ "_" ~ IntToString(stageIndex_) ~ "_" ~ IntToString(spellID_), 0)];
    history = history ~ [GetAreaCommonData(AREA_SAVE, "SpellCaptured_" ~ IntToString(gameMode_) ~ "_" ~ IntToString(playerID_) ~ "_" ~ IntToString(stageIndex_) ~ "_" ~ IntToString(spellID_), 0)];
    return history;
}

//Stage functions
function<void> Spell_SetCurrent(int spellID_) {
    assert (spellID_ >= 0, IntToString(spellID_) ~ " is an invalid spell ID.");
    SetAreaCommonData(AREA_STAGE, "Current_SpellID", spellID_);
    Spell_Seen(GetStageIndex(), spellID_);
}
function<int> Spell_GetCurrent() {
    return GetAreaCommonData(AREA_STAGE, "Current_SpellID", 0);
}

//get non/spell name based on ID
function<string> Spell_GetName(int stageIndex_, int spellID_) {
    //47 character limit (49 with \"\")
    alternative (stageIndex_)
    case (0) { //Tsurubami
        alternative (spellID_)
        case (0, 1, 2)      { return "Nonspell 1"; }
        case (3, 4)         { return "Drizzle Card \"Inkshower Downpour\""; }               //EZ, EX
        case (5)            { return "Storm Card \"Flash Flood\""; }                        //ABEX
        case (6, 7, 8)      { return "Nonspell 2"; }
        case (9, 10)        { return "Snare Card \"Talisman Skewer\""; }                    //EZ, EX
        case (11)           { return "Snare Card \"Indiscriminate Hunter\""; }              //ABEX
        case (12, 13, 14)   { return "Nonspell 3"; }
        case (15, 16)       { return "Reflection Card \"Moonlight Lattice\""; }             //EZ, EX
        case (17)           { return "Reflection Card \"Moonbeam Massacre\""; }             //ABEX
        case (18, 19, 20)   { return "Nonspell 4"; }
        case (21, 22)       { return "Senri Technique \"Donation Overflow\""; }             //EZ, EX
        case (23)           { return "Forbidden Art \"Tax Evasion\""; }                     //ABEX
        case (24, 25, 26)   { return "Nonspell 5"; }
        case (27, 28)       { return "Senri Technique \"Ink Projection Youkai Seal\""; }    //EZ, EX
        case (29)           { return "Forbidden Art \"Dual Youkai Annihilation Seal\""; }   //ABEX
        case (30, 31, 32)   { return "Nonspell 6"; }
        case (33, 34, 35)   { return "Rending Card \"Burial Under Cloudy Skies\""; }        //EZ, EX
        case (35)           { return "Severing Card \"Unconventional Grave-Digger\""; }     //ABEX
        others { return "INVALID"; }
    }
    others { assert(false, IntToString(stageIndex_) ~ " is an invalid stage index."); }
}