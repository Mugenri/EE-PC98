//Dialogue library
//keep in mind this is run from the package because the stage needs to pause
//therefore, stage-only libraries like lib_Common.dnh cannot be included
#include "./lib_SystemAll.dnh" //Boss ID constants
#include "./lib_File.dnh" //file directory constants
#include "./bosslib/lib_Character.dnh" //boss sprites/portrait retrieval

bool _endDialogue = false; //flag for end of dialogue sequence
bool _skip = false; //flag for skipping dialogue
bool _reading = false; //text currently scrolling
bool _firstLine = true; //flag to prevent accidental skipping upon loading the first line of dialogue

//Text objects
int _playerText;
int _bossText;

function<void> StartDialogue() { //call to start dialogue sequence
    TCreateTextBoxes(); //player and enemy text boxes
    _playerText = CreateDialogueText(false);
    _bossText = CreateDialogueText(true);
    wait(48); //animation time
}

function<void> EndDialogue() { //call to end dialogue sequence
    Obj_Delete(_playerText);
    Obj_Delete(_bossText);
    _endDialogue = true;
    wait(48); //animation time
}

task TCreateTextBoxes() {
    int[] playerBoxPos = [80, 320];
    int[] enemyBoxPos = [48, 192];
    int playerBox = CreateTextBox(false);
    int enemyBox = CreateTextBox(true);
    
    //fade in animation
    wait(12);
    ChangeFrame(playerBox, 1, false);
    ChangeFrame(enemyBox, 1, true);
    wait(12);
    ChangeFrame(playerBox, 2, false);
    ChangeFrame(enemyBox, 2, true);

    while (!_endDialogue) yield;
    //fade out animation
    wait(12);
    ChangeFrame(playerBox, 1, false);
    ChangeFrame(enemyBox, 1, true);
    wait(12);
    ChangeFrame(playerBox, 0, false);
    ChangeFrame(enemyBox, 0, true);
    wait(12);

    Obj_Delete(playerBox);
    Obj_Delete(enemyBox);

    function<int> CreateTextBox(bool isBoss_) {
        int obj = ObjPrim_Create(OBJ_SPRITE_2D);
        ObjPrim_SetTexture(obj, IMG_SYSTEM_TEXTBOX);
        Obj_SetRenderPriorityI(obj, RP_UI_IMG);
        ObjSprite2D_SetSourceRect(obj, 0, 0, 320, 48); //first frame
        if (isBoss_) ObjRender_SetPosition(obj, enemyBoxPos[0], enemyBoxPos[1], 1);
        else ObjRender_SetPosition(obj, playerBoxPos[0], playerBoxPos[1], 1);
        return obj;
    }

    function<void> ChangeFrame(int obj_, int frame_, bool isBoss_) {
        ObjSprite2D_SetSourceRect(obj_, 0, 0 + 48*frame_, 320, 48 + 48*frame_);
        ObjSprite2D_SetDestRect(obj_, 0, 0, 320, 48); //position controlled by objrender_setposition();
    }
}

//----------------------------------------------------
//Character Portraits
//----------------------------------------------------
function<int> CreateDialoguePortrait(string characterID_, bool isBoss_) { //creates a portrait in the player or boss position with the given characterID
    int xPos = isBoss_ ? 288 : 32;
    int yPos = isBoss_ ? 112 : 240;

    int obj = ObjPrim_Create(OBJ_SPRITE_2D);
    Obj_SetRenderPriorityI(obj, RP_UI_IMG);
    ObjPrim_SetTexture(obj, GetBossPortrait(characterID_));
    ObjRender_SetPosition(obj, xPos, yPos, 1);

    return obj;
}

function<void> SetPortrait(int obj_, int frame_) { //assumes character portraits are in a 4x3 grid of 128x128 images. frames advance from top left to bottom right
    int top = 128 * trunc(frame_ / 4);
    int left = 128 * (frame_ % 4);
    //change portrait frame
    ObjSprite2D_SetSourceRect(obj_, left, top, left+128, top+128);
    ObjSprite2D_SetDestRect(obj_, 0, 0, 128, 128); //position controlled by objrender_setposition();
}

//----------------------------------------------------
//Text Control
//----------------------------------------------------
function<int> CreateDialogueText(bool isBoss_) { //creates the dialogue text object
    int xPos = isBoss_ ? 49 : 161;
    int yPos = isBoss_ ? 191 : 319;

    int obj = ObjText_Create();
    ObjText_SetFontType(obj, SYS_FONT);
    ObjText_SetFontSize(obj, 16);
    ObjText_SetVertexColor(obj, 0xFF000000 + COLOR_WHITE);
    ObjText_SetFontBorderType(obj, BORDER_NONE);
    ObjText_SetLinePitch(obj, 0);
    ObjText_SetMaxWidth(obj, 242);
    Obj_SetRenderPriorityI(obj, RP_UI_TEXT);
    ObjRender_SetPosition(obj, xPos, yPos, 1);
    return obj;
}

function<void> SetText(bool isBoss_, string text_) { //Sets selected text field to desired new text. Colors blue if left unchanged for a line
    //29 characters per line max, font is unispaced
    //-----------------------------   <-- this long
    if (isBoss_) {
        ObjText_SetHorizontalAlignment(_bossText, ALIGNMENT_LEFT);
        ObjText_SetVertexColor(_bossText, 0xFF000000 + COLOR_WHITE);
        ObjText_SetVertexColor(_playerText, 0xFF000000 + COLOR_BLUE);
        TTextScroll(_bossText, text_);
    } else {
        ObjText_SetVertexColor(_playerText, 0xFF000000 + COLOR_WHITE);
        ObjText_SetVertexColor(_bossText, 0xFF000000 + COLOR_BLUE);
        TTextScroll(_playerText, text_);
    }
}

function<void> SetBossTitle(string text_) { //Centers text for use in boss titles/names
    ObjText_SetHorizontalAlignment(_bossText, ALIGNMENT_CENTER);
    ObjText_SetVertexColor(_bossText, 0xFF000000 + COLOR_WHITE);
    ObjText_SetVertexColor(_playerText, 0xFF000000 + COLOR_BLUE);
    TTextScroll(_bossText, text_);
}

task TTextScroll(int obj_, string text_) { //Makes text fill gradually in text boxes
    _reading = true;
    string[] tempStrings = SplitString(text_, "/"); //use / for newlines instead of [r]
    string tempString = "";
    if (GetVirtualKeyState(VK_OK) == KEY_PUSH) { //Prevents skipping the yield
        SetVirtualKeyState(VK_OK, KEY_FREE);
    }
    ascent (i in 0..length(tempStrings)) { //list of substrings
        ascent (j in 0..length(tempStrings[i])) { //for each character in a substring
            tempString = tempString ~ [tempStrings[i][j]];
            ObjText_SetText(obj_, tempString);
            if (GetVirtualKeyState(VK_OK) != KEY_PUSH && !_skip) { //skip if player presses button or dialogue is being skipped
                yield;
            }
        }
        tempString = tempString ~ ['[','r',']']; //append a newline after each substring
    }
    if (GetVirtualKeyState(VK_OK) == KEY_PUSH) SetVirtualKeyState(VK_OK, KEY_FREE); //Prevents the keystate from carrying over to the reading check in WaitForInput()
    _reading = false;
}

//----------------------------------------------------
//Utility
//----------------------------------------------------
function<void> WaitForInput() { //waits for player input to advance text
    if (_firstLine) {
		_firstLine = false;
		while (GetVirtualKeyState(VK_OK) != KEY_FREE) yield;
	}
    yield;
    int skipFlag = 0;
	loop {
        SkipCheck(skipFlag);
		if ((_skip || (!_reading && GetVirtualKeyState(VK_OK) == KEY_PUSH))) return;
		if (GetVirtualKeyState(VK_OK) == KEY_HOLD || GetVirtualKeyState(VK_OK) == KEY_PUSH) skipFlag++;
		else skipFlag = 0;
		yield;
    }
}

function<bool> SkipCheck(int flag_) { //hold key to skip dialogue
    if (!_skip && flag_ > 60) {
        _skip = true;
        flag_ = 0;
    }
    if (GetVirtualKeyState(VK_OK) != KEY_HOLD) _skip = false;
}

function<void> SummonBoss(int fadeIn_, int between_, int fadeOut_, string bossID_, int xPos_, int yPos_) { //Screen whiteout that places the boss sprite 
    //boss sprite to be placed, autodeletes upon script closure
    int bossSprite = ObjPrim_Create(OBJ_SPRITE_2D);
    Obj_SetRenderPriorityI(bossSprite, RP_UI_IMG);
    ObjPrim_SetTexture(bossSprite, GetBossSprite(bossID_));

    //screen whiteout
    int whiteout = ObjPrim_Create(OBJ_SPRITE_2D);
    Obj_SetRenderPriorityI(whiteout, RP_UI_MAX);
    ObjSprite2D_SetSourceRect(whiteout, 0, 0, 384, 368);
    ObjSprite2D_SetDestRect(whiteout, 0, 0, 384, 368);
    ObjRender_SetPosition(whiteout, 32, 16, 1); //corner of stg window
    ObjRender_SetColor(whiteout, COLOR_WHITE);

    //animation
    descent (i in 0..fadeIn_) {
        int alpha = 255 - (i+1)/fadeIn_*255;
        ObjRender_SetAlpha(whiteout, alpha);
        yield;
    }
    ObjRender_SetAlpha(whiteout, 255);
    //if i try to use objrender_setvisible on this instead of setting rects at this point it makes the whiteout effect flicker, no idea why.
    ObjSprite2D_SetSourceRect(bossSprite, 0, 0, 64, 64); //THIS MUST BE STANDARDIZED
    ObjSprite2D_SetDestCenter(bossSprite);
    ObjRender_SetPosition(bossSprite, xPos_ + 32, yPos_ + 16, 1); //shifted to align with stg window coordinates

    wait(between_);
    ascent (i in 0..fadeOut_) {
        int alpha = 255 - (i+1)/fadeOut_*255;
        ObjRender_SetAlpha(whiteout, alpha);
        yield;
    }
    Obj_Delete(whiteout);
}