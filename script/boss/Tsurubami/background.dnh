#include "./../../lib/lib_Common.dnh"
bool _bSpell = false;

@Initialize {
    SetAutoDeleteObject(true);
    TBackground();
    TSpellBackground();
}

@MainLoop {
    _objScene = GetEnemyBossSceneObjectID(); //TODO probably change this maybe do away with background "scripts" altogether and just use a task prob
	if (_objScene != ID_INVALID && ObjEnemyBossScene_GetInfo(_objScene, INFO_IS_SPELL))
	{
		_bSpell = true;
	}
	else
	{
		_bSpell = false;
	}
	yield;
}

task TBackground() {
    //bg
    int bg = ObjPrim_Create(OBJ_SPRITE_2D);
    ObjPrim_SetTexture(bg, IMG_BG_TSURUBAMI);
    ObjSprite2D_SetSourceRect(bg, 0, 0, 384, 368);
    ObjSprite2D_SetDestRect(bg, 0, 0, 384, 368);
    Obj_SetRenderPriorityI(bg, RP_STG_BG);

    int count = 30;
    int color = 0;
    bool increment = true;

    TLineEffect();

    loop {
        if (_bSpell) Obj_SetVisible(bg, false);
        else Obj_SetVisible(bg, true);

        ObjRender_SetColor(bg, color, color, color);

        if (increment) {
            count++;
        } else {
            count--;
        }

        if (count >= 209) {
            increment = false;
        } else if (count < 30) {
            increment = true;
        }

        color = truncate(count/60) * 8 + 8;
        yield;
    }

    task TLineEffect() {
        //Used for movement
        int count = 0;

        //starting point for line columns/rows
        int xOrigin = -17;
        int yOrigin = -26;

        int x = xOrigin;
        int y = yOrigin;

        //Vertical Lines
        loop (5) {
            TCreateLine(x, y, 71, 7, true);
            x += 139;
        }

        x = xOrigin - 139; //need one point back to cover full range of motion
        y = yOrigin + 70; //Height of a rectangle

        //Horizontal Lines
        loop (5) {
            TCreateLine(x, y, 140, 7, false);
            y += 70;
        }

        //Movement
        loop {
            if (count >= 140) {
                count = 0;
            }
            count++;
            yield;
        }

        task TCreateLine(int xStart_, int yStart_, int step_, int points_, bool vertical_) {
            int[][] positions = [];

            int line = ObjPrim_Create(OBJ_PRIMITIVE_2D);
            ObjPrim_SetPrimitiveType(line, PRIMITIVE_LINESTRIP);
            Obj_SetRenderPriorityI(line, RP_STG_BG);
            ObjPrim_SetVertexCount(line, points_);
            ascent (i in 0..points_) {
                ObjPrim_SetVertexColor(line, i, 78, 78, 78);
            }
            ascent (i in 0..points_) {
                ObjPrim_SetVertexPosition(line, i, xStart_, yStart_, 1);
                positions = positions ~ [[xStart_, yStart_]];
                if (vertical_) yStart_ += step_;
                else xStart_ += step_;
            }

            //set positions based on grid position and multiplier based on distance from the middle
            loop {
                if (_bSpell) Obj_SetVisible(line, false);
                else Obj_SetVisible(line, true);
                ascent (i in 0..length(positions)) {
                    int xCurr = positions[i][0] - count;
                    int yCurr = positions[i][1];
                    xCurr -= (xCurr - MID_X) * 0.06 * (absolute(yCurr - MID_Y) * 0.02);
                    yCurr += (yCurr - MID_Y) * 0.06 * (absolute(xCurr - MID_X) * 0.02);

                    ObjPrim_SetVertexPosition(line, i, xCurr, yCurr, 1);
                }
                yield;
            }
        }
    }
}

task TSpellBackground() { //TODO very temporary
    //spell bg
    int bg = ObjPrim_Create(OBJ_SPRITE_2D);
    ObjPrim_SetTexture(bg, IMG_BG_TSURUBAMI);
    ObjSprite2D_SetSourceRect(bg, 384, 0, 768, 368);
    ObjSprite2D_SetDestRect(bg, 0, 0, 384, 368);
    Obj_SetRenderPriorityI(bg, RP_STG_BG);

    int count = 30;
    int color = 0;
    real angle = 0;
    bool increment = true;

    TSpellEffect();

    loop {
        if (!_bSpell) Obj_SetVisible(bg, false);
        else Obj_SetVisible(bg, true);

        ObjRender_SetColor(bg, color, color, color);

        if (increment) {
            count++;
        } else {
            count--;
        }

        if (count >= 209) {
            increment = false;
        } else if (count < 30) {
            increment = true;
        }

        color = truncate(count/60) * 8 + 8;
        yield;
    }

    task TSpellEffect() {
        loop {
            real y = rand_int(0, 368);
            real speed = rand(1.1, 2);
            TCreateLine(y, speed, true);
            y = rand(0, 368);
            speed = rand(1.1, 2);
            TCreateLine(y, speed, false);
            wait(6);
        }

        task TCreateLine(int yPos_, real speed_, bool front_) {
            int color = front_ ? COLOR_GRAY : COLOR_GRAY_D;
            int priority = front_ ? RP_STG_BG : RP_STG_BG - 1;
            real xPos = front_ ? -20 : GetStgFrameWidth() + 20;
            int len = 15;
            if (!front_) speed_ *= -1; //move other direction if in background
            int line = ObjPrim_Create(OBJ_PRIMITIVE_2D);
            ObjPrim_SetPrimitiveType(line, PRIMITIVE_LINELIST);
            ObjPrim_SetVertexCount(line, 2);
            ascent (i in 0..2) {
                ObjPrim_SetVertexColor(line, i, color);
                Obj_SetRenderPriorityI(line, priority);
            }
            loop (trunc(368 / absolute(speed_)) + 60) { //rough amount of time it will take the lines to cross the screen
                if (!_bSpell) Obj_SetVisible(line, false);
                else Obj_SetVisible(line, true);
                ObjPrim_SetVertexPosition(line, 0, xPos, yPos_, 1);
                ObjPrim_SetVertexPosition(line, 1, xPos + len, yPos_, 1);
                xPos += speed_;
                yield;
            }
            Obj_Delete(line);
        }
    }
}