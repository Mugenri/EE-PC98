//Tsurubami background library
#include "./../../lib/lib_Background.dnh"

function<void> ChangeIndex(int index_, int priority_) {
    //change to index (starts shutdown for current bg)
    _bIndex = index_;
    alternative (index_)
    case (0) { TBackground(0, priority_); }
    case (1) { TSpellBackground(1, priority_); }
    case (2) { TBackgroundStage(2, priority_); }
    others { assert(false, "Invalid background index."); }
}

task TBackgroundStage(int index_, int priority_) {
    bool exitFlag = false;
    //black bg
    int black = ObjPrim_Create(OBJ_PRIMITIVE_2D);
    ObjSprite2D_SetSourceRect(black, 0, 0, MAX_X, MAX_Y);
    ObjSprite2D_SetDestRect(black, 0, 0, MAX_X, MAX_Y);
    ObjRender_SetColor(black, COLOR_BLACK);
    Obj_SetRenderPriorityI(black, priority_);
    //bg
    int bg = ObjPrim_Create(OBJ_SPRITE_2D);
    ObjPrim_SetTexture(bg, IMG_BG_TSURUBAMI);
    ObjSprite2D_SetSourceRect(bg, 0, 368, 384, 736);
    ObjSprite2D_SetDestRect(bg, 0, 0, MAX_X, MAX_Y);
    Obj_SetRenderPriorityI(bg, priority_ + 1); //render over prims

    int count = 0;

    while (!exitFlag) {
        if (index_ != _bIndex) {
            TExit();
            index_ = _bIndex;
        }
        if (count % 90 == 0) TCircle();
        count++;
        yield;
    }

    Obj_Delete(bg);
    Obj_Delete(black);

    task TCircle() {
        int circle = InitPrim2D(PRIMITIVE_LINESTRIP, 33, priority_);
        ascent (i in 0..33) ObjPrim_SetVertexColor(circle, i, COLOR_GRAY_D);

        for (real i = 1; i < 300; i *= 1.05) {
            real angle = 0;
            ascent (j in 0..33) {
                ObjPrim_SetVertexPosition(circle, j, MID_X + i * cos(angle), MID_Y + i * sin(angle), 1);
                angle += 360/32;
            }
            if (!exitFlag) yield;
        }
        Obj_Delete(circle);
    }

    task TExit () { //exit background task
        int timer = _transitionTime;
        while (timer > 0) {
            timer--;
            yield;
        }
        exitFlag = true;
    }
}

task TBackground(int index_, int priority_) {
    bool exitFlag = false;
    //bg
    int bg = ObjPrim_Create(OBJ_SPRITE_2D);
    ObjPrim_SetTexture(bg, IMG_BG_TSURUBAMI);
    ObjSprite2D_SetSourceRect(bg, 0, 0, 384, 368);
    ObjSprite2D_SetDestRect(bg, 0, 0, MAX_X, MAX_Y);
    Obj_SetRenderPriorityI(bg, priority_);

    int count = 30;
    int color = 0;
    bool increment = true;

    TLineEffect();

    while (!exitFlag) {
        if (index_ != _bIndex) {
            TExit();
            index_ = _bIndex;
        }
        ObjRender_SetColor(bg, color, color, color);

        if (increment) count++;
        else count--;

        if (count >= 209) increment = false;
        else if (count < 30) increment = true;

        color = truncate(count/60) * 8 + 8;
        yield;
    }

    Obj_Delete(bg);

    task TLineEffect() {
        //Used for movement
        int count = 0;

        //starting point for line columns/rows
        int xOrigin = -17;
        int yOrigin = -26;

        int x = xOrigin;
        int y = yOrigin;

        //Vertical Lines
        loop (5) {
            TCreateLine(x, y, 71, 7, true);
            x += 139;
        }

        x = xOrigin - 139; //need one point back to cover full range of motion
        y = yOrigin + 70; //Height of a rectangle

        //Horizontal Lines
        loop (5) {
            TCreateLine(x, y, 140, 7, false);
            y += 70;
        }

        //Movement
        while (!exitFlag) {
            if (count >= 140) count = 0;
            count++;
            yield;
        }

        task TCreateLine(int xStart_, int yStart_, int step_, int points_, bool vertical_) {
            int[][] positions = [];

            int line = InitPrim2D(PRIMITIVE_LINESTRIP, points_, priority_);
            ascent (i in 0..points_) {
                ObjPrim_SetVertexColor(line, i, 78, 78, 78);
            }
            ascent (i in 0..points_) {
                ObjPrim_SetVertexPosition(line, i, xStart_, yStart_, 1);
                positions = positions ~ [[xStart_, yStart_]];
                if (vertical_) yStart_ += step_;
                else xStart_ += step_;
            }

            //set positions based on grid position and multiplier based on distance from the middle
            while (!exitFlag) {
                ascent (i in 0..length(positions)) {
                    int xCurr = positions[i][0] - count;
                    int yCurr = positions[i][1];
                    xCurr -= (xCurr - MID_X) * 0.06 * (absolute(yCurr - MID_Y) * 0.02);
                    yCurr += (yCurr - MID_Y) * 0.06 * (absolute(xCurr - MID_X) * 0.02);

                    ObjPrim_SetVertexPosition(line, i, xCurr, yCurr, 1);
                }
                yield;
            }
            Obj_Delete(line);
        }
    }

    task TExit () { //exit background task
        int timer = _transitionTime;
        while (timer > 0) {
            timer--;
            yield;
        }
        exitFlag = true;
    }
}

task TSpellBackground(int index_, int priority_) { //TODO very temporary
    bool exitFlag = false;
    //spell bg
    int bg = ObjPrim_Create(OBJ_SPRITE_2D);
    ObjPrim_SetTexture(bg, IMG_BG_TSURUBAMI);
    ObjSprite2D_SetSourceRect(bg, 384, 0, 768, 368);
    ObjSprite2D_SetDestRect(bg, 0, 0, MAX_X, MAX_Y);
    Obj_SetRenderPriorityI(bg, priority_);

    int count = 30;
    int color = 0;
    real angle = 0;
    bool increment = true;

    TSpellEffect();

    while (!exitFlag) {
        if (index_ != _bIndex) {
            TExit();
            index_ = _bIndex;
        }
        ObjRender_SetColor(bg, color, color, color);

        if (increment) count++;
        else count--;

        if (count >= 209) increment = false;
        else if (count < 30) increment = true;

        color = truncate(count/60) * 8 + 8;
        yield;
    }

    Obj_Delete(bg);

    task TSpellEffect() {
        while (!exitFlag) {
            real y = rand_int(0, 368);
            real speed = rand(1.1, 2);
            TCreateLine(y, speed, true);
            y = rand(0, 368);
            speed = rand(1.1, 2);
            TCreateLine(y, speed, false);
            wait(6);
        }

        task TCreateLine(int yPos_, real speed_, bool front_) {
            int color = front_ ? COLOR_GRAY : COLOR_GRAY_D;
            int priority = front_ ? priority_ + 1 : priority_;
            real xPos = front_ ? -20 : GetStgFrameWidth() + 20;
            int len = 15;
            if (!front_) speed_ *= -1; //move other direction if in background
            int line = InitPrim2D(PRIMITIVE_LINELIST, 2, priority);
            ascent (i in 0..2) {
                ObjPrim_SetVertexColor(line, i, color);
            }
            loop (trunc(368 / absolute(speed_)) + 60) { //rough amount of time it will take the lines to cross the screen
                if (exitFlag) break;
                ObjPrim_SetVertexPosition(line, 0, xPos, yPos_, 1);
                ObjPrim_SetVertexPosition(line, 1, xPos + len, yPos_, 1);
                xPos += speed_;
                yield;
            }
            Obj_Delete(line);
        }
    }

    task TExit () { //exit background task
        int timer = _transitionTime;
        while (timer > 0) {
            timer--;
            yield;
        }
        exitFlag = true;
    }
}