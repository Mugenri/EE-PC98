#TouhouDanmakufu[Single]
#ScriptVersion[3]
#Title["nonspell1"]
#System["./../../system/System.dnh"]
#Background["./../../system/TestBG.dnh"]

#include "./../../lib/lib_Common.dnh"
#include "./tsuruAnime.dnh"
#include "./lib_Tsuru.dnh"
#include "./../../lib/lib_Shot.dnh"

int objBoss;
int count = -120;
int loopTime = 200;

@Event {
    alternative (GetEventType())
    case (EV_REQUEST_LIFE) {
        SetScriptResult(350);
    }
    case (EV_REQUEST_TIMER) {
        SetScriptResult(60);
    }
    case (EV_REQUEST_SPELL_SCORE) {
        SetScriptResult(1000000);
    }
}

@Initialize {
    LoadShotData();
    objBoss = ObjEnemy_Create(OBJ_ENEMY_BOSS);
    ObjEnemy_Regist(objBoss);
    InitCommon(); //TODO change to initboss and a boss library
    ObjMove_SetPosition(objBoss, MID_X, 60);
    

    //TBombBarrier();

    TDrawBoss(objBoss);
    TFinalize;
}

@MainLoop {
    ObjEnemy_SetIntersectionCircleToShot(objBoss, ObjMove_GetX(objBoss), ObjMove_GetY(objBoss), 32);
    ObjEnemy_SetIntersectionCircleToPlayer(objBoss, ObjMove_GetX(objBoss), ObjMove_GetY(objBoss), 24);
    if (count % loopTime == 0 && count >= 0) {
        TPatternB(1);
        TPatternB(-1);
    }
    count++;

    yield;
}

task TFinalize() {
    while (ObjEnemy_GetInfo(objBoss, INFO_LIFE) > 0) yield;
    real xPos = ObjMove_GetX(objBoss);
    real yPos = ObjMove_GetY(objBoss);
    Obj_Delete(objBoss);

    //Need to put in a library, not do this if the spell is timed out
    //Actual MS bullet cancel score progression
    int score = 10;
    int scoreBonus = 10;
    int numBullets = 0;
    real radius = 100;
    loop (5) {
        for each (shot in GetShotIdInCircleA2(MID_X, MID_Y - GetStgFrameHeight() / 2, radius, TARGET_ENEMY)) {
            Obj_SetValueI(shot, SHOT_SCORE, score);
            if (numBullets < 40 && Obj_GetType(shot) == OBJ_SHOT && rand_int(1, 4) == 1) { //random <= 40 bullets drop point items
                Obj_SetValueI(shot, SHOT_DROP_ITEM, true);
                numBullets++;
            }
            score += scoreBonus;
            scoreBonus += 30;
            score = min(score, 12800);
        }
        DeleteShotInCircle(TYPE_SHOT, TYPE_ITEM, xPos, yPos, radius);
        radius += 100;
    }
    //^^
    DeleteShotAll(TYPE_ALL, TYPE_ITEM);
    SetAutoDeleteObject(true);
    CloseScript(GetOwnScriptID());
    return;
}

task TPatternA() {
    AnimeCharge();
    wait(20);
    if (ObjEnemy_GetInfo(objBoss, INFO_LIFE) <= 0) return;
    loop (3) {
        loop (5) {
            real angleT = rand(0, 360);
            loop (10) {
                if (ObjEnemy_GetInfo(objBoss, INFO_LIFE) <= 0) return;
                int obj = CreateShotUA1(ObjMove_GetX(objBoss), ObjMove_GetY(objBoss), 4, angleT, WHITE_2NEEDLE, 20, A_WHITE_BALL);
                angleT += 360/10;
            }
            wait(6);
        }
        wait(6);
    }
    wait(10);
    AnimeCharge();
}

task TPatternB(int dir_) {
    real angleT = 0;

    loop (8) {
        real x = ObjMove_GetX(objBoss) + 30 * cos(angleT);
        real y = ObjMove_GetY(objBoss) + 30 * sin(angleT);
        int obj = CreateStraightLaserUA1(x, y, dottheta(x, y, GetPlayerX(), GetPlayerY()), 550, 60, 0xFF00FF, 60);
        angleT += 45;
        TMove(obj);
    }

    task TMove(int laser_) {
        real x = ObjMove_GetX(laser_);
        loop (50) {
            ObjMove_SetX(laser_, x);
            ObjStLaser_SetAngle(laser_, GetAngleToPlayer(laser_));
            x += 3 * dir_;
            yield;
        }
        loop (70) {
            ObjMove_SetX(laser_, x);
            x += 1.5 * dir_;
            yield;
        }
    }
}

task TPatternC() {
    real angle = 180;
    loop (11) {
        if (!ObjEnemy_GetInfo(objBoss, INFO_LIFE) > 0) return;
        int dist = 25;
        let obj = CreateLooseLaserUA1(ObjMove_GetX(objBoss) + dist * cos(angle), ObjMove_GetY(objBoss) + dist * sin(angle), 4.5, angle, 120, 0x444444, 0);
        angle -= 18;
        wait(5);
    }
    angle = 0;
    loop (11) {
        if (!ObjEnemy_GetInfo(objBoss, INFO_LIFE) > 0) return;
        int dist = 15;
        CreateLooseLaserUA1(ObjMove_GetX(objBoss) + dist * cos(angle), ObjMove_GetY(objBoss) + dist * sin(angle), 4.5, angle, 120, 0x444444, 0);
        angle += 18;
        wait(5);
    }
}

task TPatternD() {
    loop (40) {
        CreateShotUA1(ObjMove_GetX(objBoss), ObjMove_GetY(objBoss), 5, GetAngleToPlayer(objBoss), WHITE_2NEEDLE, 0, A_WHITE_BALL);
        wait(2);
    }
}

task TPatternE() {
    real angleT = round(rand(0, 360));
    real xPos = rand(-15, 15);
    real yPos = rand(-15, 15);
    int bSprite = round(rand(0, 1)) * 5;
    loop(32){
        if (ObjEnemy_GetInfo(objBoss, INFO_LIFE) <= 0) return;
        CreateShotUA1(ObjMove_GetX(objBoss) + xPos, ObjMove_GetY(objBoss) + yPos, 5, angleT, 4 + bSprite, 0, A_WHITE_BALL);
        angleT += 360/32;
    }
}

task TPatternF(int dir_) {
    real angleT = 90 + 45 * dir_;
    real increment = 0.05;
    
    loop(550) {
        if (ObjEnemy_GetInfo(objBoss, INFO_LIFE) <= 0) return;
        CreateShotUA1(MID_X, MID_Y - 15, 2, angleT + increment * dir_ + 10, BLACK_BALL, 0, A_WHITE_BALL);
        CreateShotUA1(MID_X, MID_Y - 15, 2, angleT + increment * dir_, BLACK_BALL, 0, A_WHITE_BALL);
        CreateShotUA1(MID_X, MID_Y - 15, 2, angleT + increment * dir_ - 10, BLACK_BALL, 0, A_WHITE_BALL);
        increment *= 1.04;
        angleT += increment * dir_;
        wait(2);
    }
} 

task TPatternG() {
    CreateShotUA2(MID_X, MID_Y, 2, 90, 0.2, 10, BLACK_BALL, 0, A_WHITE_BALL);
    wait(60);
    CreateShotUB1(MID_X, MID_Y, 1, 2, BLACK_2NEEDLE, 0, A_WHITE_BALL);
    wait(60);
    CreateShotUB2(MID_X, MID_Y, 1, 2, 0.2, 0.2, 5, 3, WHITE_CARD, 0, A_WHITE_BALL);
}

task TPatternH() {
    CreateStraightLaserUA1(MID_X - 40, MID_Y, 0, 80, 1000, 0x00FF00, 30);
}