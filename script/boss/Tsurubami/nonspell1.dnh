#TouhouDanmakufu[Single]
#ScriptVersion[3]
#Title["nonspell1"]
#System["./../../system/System.dnh"]
//#Background["./../../system/TestBG.dnh"]

#include "./../../lib/lib_Boss.dnh"
#include "./lib_Tsuru.dnh"

int _objBoss;
int _count = -120;
int _loopTime = 3600;

@Event {
    alternative (GetEventType())
    case (EV_REQUEST_LIFE) {
        SetScriptResult(100);
    }
    case (EV_REQUEST_TIMER) {
        SetScriptResult(60);
    }
    case (EV_REQUEST_SPELL_SCORE) {
        SetScriptResult(1000000);
    }
}

@Initialize {
    _objBoss = ObjEnemy_Create(OBJ_ENEMY_BOSS);
    ObjEnemy_Regist(_objBoss);
    InitBoss();
    ObjMove_SetPosition(_objBoss, MID_X, 60);
    
    //TBombBarrier(_objBoss);

    TDrawBoss(_objBoss);
    TFinalize();
}

@MainLoop {
    ObjEnemy_SetIntersectionCircleToShot(_objBoss, ObjMove_GetX(_objBoss), ObjMove_GetY(_objBoss), 32);
    ObjEnemy_SetIntersectionCircleToPlayer(_objBoss, ObjMove_GetX(_objBoss), ObjMove_GetY(_objBoss), 24);
    if (_count % _loopTime == 0 && _count >= 0) {
        async {
            //int objspark = MasterSpark(MID_X, ObjMove_GetY(_objBoss), 90, 400, 336, 60, COLOR_BLUE, COLOR_INDIGO_L, 90);
            //Transition_Tilt(true); //TODO need to find a way to control the background with this
            TPatternM();
            //TPatternB(1);
        }
    }
    _count++;

    yield;
}

task TFinalize() {
    while (ObjEnemy_GetInfo(_objBoss, INFO_LIFE) > 0) yield;
    real xPos = ObjMove_GetX(_objBoss);
    real yPos = ObjMove_GetY(_objBoss);

    //TODO Need to put in a library, not do this if the spell is timed out (or not a spell), and probably condense it
    int score = 10;
    int scoreBonus = 10;
    int numBullets = 0;
    real radius = 100;
    //decide items
    loop (5) {
        for each (shot in GetShotIdInCircleA2(MID_X, MID_Y - GetStgFrameHeight() / 2, radius, TARGET_ENEMY)) {
            if (ObjMove_GetX(shot) < -10 || ObjMove_GetX(shot) > GetStgFrameWidth() + 10 || ObjMove_GetY(shot) < -10 || ObjMove_GetY(shot) > GetStgFrameHeight() + 10) {
                continue; //no items spawn off screen
            }  
            if (numBullets < 40 && Obj_GetType(shot) == OBJ_SHOT && rand_int(1, 4) == 1) { //random <= 40 bullets drop point items
                Obj_SetValueI(shot, SHOT_DROP_ITEM, true);
                numBullets++;
            }
        }
        radius += 100;
    }
    //decide score
    for each (shot in GetShotIdInCircleA2(xPos, yPos, 600, TARGET_ENEMY)) {
        if (ObjMove_GetX(shot) < -10 || ObjMove_GetX(shot) > GetStgFrameWidth() + 10 || ObjMove_GetY(shot) < -10 || ObjMove_GetY(shot) > GetStgFrameHeight() + 10) {
            Obj_SetValue(shot, SHOT_SCORE, 0); //no points for off screen bullets;
        } else if (score <= 12800) {
            Obj_SetValueI(shot, SHOT_SCORE, score);
            score += scoreBonus;
            scoreBonus += 10;
        }
        //bullets with no value assigned are assumed 12800
    }
    //^^
    DeleteShotAll(TYPE_ALL, TYPE_ITEM);
    //TRANSITION IF SPELL CARD GOES HERE
    wait(30);
    Obj_Delete(_objBoss);
    SetAutoDeleteObject(true);
    CloseScript(GetOwnScriptID());
    return;
}

task TPatternA() {
    AnimeCharge();
    wait(20);
    if (ObjEnemy_GetInfo(_objBoss, INFO_LIFE) <= 0) return;
    loop (3) {
        loop (5) {
            real angleT = rand(0, 360);
            loop (25) {
                if (ObjEnemy_GetInfo(_objBoss, INFO_LIFE) <= 0) return;
                int obj = CreateShotUA1(ObjMove_GetX(_objBoss), ObjMove_GetY(_objBoss), 1.2, angleT, 1, 0, 2000, 0);
                angleT += 360/25;
            }
            wait(100);
        }
        wait(20);
    }
    wait(10);
    AnimeCharge();
}

task TPatternB(int dir_) {
    real angleT = 0;

    loop (8) {
        real x = ObjMove_GetX(_objBoss) + 30 * cos(angleT);
        real y = ObjMove_GetY(_objBoss) + 30 * sin(angleT);
        int obj = CreateStraightLaserUA1(x, y, dottheta(x, y, GetPlayerX(), GetPlayerY()), 550, 60, 0xFF00FF, 60);
        angleT += 45;
        TMove(obj);
    }

    task TMove(int laser_) {
        real x = ObjMove_GetX(laser_);
        loop (50) {
            ObjMove_SetX(laser_, x);
            ObjStLaser_SetAngle(laser_, GetAngleToPlayer(laser_));
            x += 3 * dir_;
            yield;
        }
        loop (70) {
            ObjMove_SetX(laser_, x);
            x += 1.5 * dir_;
            yield;
        }
    }
}

task TPatternC() {
    real angle = 180;
    loop (11) {
        if (!ObjEnemy_GetInfo(_objBoss, INFO_LIFE) > 0) return;
        int dist = 25;
        let obj = CreateLooseLaserUA1(ObjMove_GetX(_objBoss) + dist * cos(angle), ObjMove_GetY(_objBoss) + dist * sin(angle), 4.5, angle, 120, 0x444444, 0);
        angle -= 18;
        wait(5);
    }
    angle = 0;
    loop (11) {
        if (!ObjEnemy_GetInfo(_objBoss, INFO_LIFE) > 0) return;
        int dist = 15;
        CreateLooseLaserUA1(ObjMove_GetX(_objBoss) + dist * cos(angle), ObjMove_GetY(_objBoss) + dist * sin(angle), 4.5, angle, 120, 0x444444, 0);
        angle += 18;
        wait(5);
    }
}

task TPatternD() {
    loop (40) {
        CreateShotUA1(ObjMove_GetX(_objBoss), ObjMove_GetY(_objBoss), 5, GetAngleToPlayer(_objBoss), SHOT_WHITE+NEEDLES, 0, 0, 0);
        wait(2);
    }
}

task TPatternE() {
    real angleT = round(rand(0, 360));
    real xPos = rand(-15, 15);
    real yPos = rand(-15, 15);
    int bSprite = round(rand(0, 1)) * 5;
    loop(32){
        if (ObjEnemy_GetInfo(_objBoss, INFO_LIFE) <= 0) return;
        CreateShotUA1(ObjMove_GetX(_objBoss) + xPos, ObjMove_GetY(_objBoss) + yPos, 5, angleT, 4 + bSprite, 0, 0, 0);
        angleT += 360/32;
    }
}

task TPatternF(int dir_) {
    real angleT = 90 + 45 * dir_;
    real increment = 0.05;
    
    loop(550) {
        if (ObjEnemy_GetInfo(_objBoss, INFO_LIFE) <= 0) return;
        CreateShotUA1(MID_X, MID_Y - 15, 2, angleT + increment * dir_ + 10, SHOT_BLACK+BALL_S, 0, 0, 0);
        CreateShotUA1(MID_X, MID_Y - 15, 2, angleT + increment * dir_, SHOT_BLACK+BALL_S, 0, 0, 0);
        CreateShotUA1(MID_X, MID_Y - 15, 2, angleT + increment * dir_ - 10, SHOT_BLACK+BALL_S, 0, 0, 0);
        increment *= 1.04;
        angleT += increment * dir_;
        wait(2);
    }
} 

task TPatternG() {
    CreateShotUA2(MID_X, MID_Y, 2, 90, 0.2, 10, SHOT_BLACK+BALL_S, 0, 0, 0);
    wait(60);
    CreateShotUB1(MID_X, MID_Y, 1, 2, SHOT_BLACK+NEEDLES, 0, 0, 0);
    wait(60);
    CreateShotUB2(MID_X, MID_Y, 1, 2, 0.2, 0.2, 5, 3, SHOT_WHITE+CARD, 0, 0, 0);
}

task TPatternH() {
    CreateStraightLaserUA1(MID_X - 40, MID_Y, 0, 80, 1000, 0x00FF00, 30);
}

task TPatternI() {
    Primitive_ContractPolygon2D(ObjMove_GetX(_objBoss), ObjMove_GetY(_objBoss), 45, 0, 100, 30, 32, COLOR_WHITE, false, RP_STG_EFF_LOW);
    wait(3);
    Particle_ContractRing(ObjMove_GetX(_objBoss), ObjMove_GetY(_objBoss), -15, 100, 90, 30, 8, COLOR_GRAY_D);
    Particle_ContractRing(ObjMove_GetX(_objBoss), ObjMove_GetY(_objBoss), 15, 100, -90, 30, 8, COLOR_GRAY_D);
    wait(3);
    Particle_ContractRing(ObjMove_GetX(_objBoss), ObjMove_GetY(_objBoss), -15, 100, 90, 30, 8, COLOR_GRAY);
    Particle_ContractRing(ObjMove_GetX(_objBoss), ObjMove_GetY(_objBoss), 15, 100, -90, 30, 8, COLOR_GRAY);
    wait(3);
    Particle_ContractRing(ObjMove_GetX(_objBoss), ObjMove_GetY(_objBoss), -15, 100, 90, 30, 8, COLOR_GRAY);
    Particle_ContractRing(ObjMove_GetX(_objBoss), ObjMove_GetY(_objBoss), 15, 100, -90, 30, 8, COLOR_GRAY);
    wait(20);
    int shot1 = CreateShotA1(ObjMove_GetX(_objBoss), ObjMove_GetY(_objBoss), 10, 50, SHOT_BLACK+PILL_S, 0);
    int shot2 = CreateShotA1(ObjMove_GetX(_objBoss), ObjMove_GetY(_objBoss), 10, 130, SHOT_BLACK+PILL_S, 0);
    ObjShot_SetSpellResist(shot1, true);
    ObjShot_SetSpellResist(shot2, true);
    loop (3) {
        if (ObjEnemy_GetInfo(_objBoss, INFO_LIFE) <= 0) return;
        SpawnShot(shot1);
        SpawnShot(shot2);
        wait(12);
    }

    function SpawnShot(int obj_) {
        real x = ObjMove_GetX(obj_);
        real y = ObjMove_GetY(obj_);
        loop (20) {
            real speed = rand(0.4, 0.9);
            real angle = rand(0, 360);
            CreateShotUA1(x + speed * 5 * cos(angle), y + speed * 5 * sin(angle), speed, angle, SHOT_WHITE+NEEDLES, 0, 0, 0);
        }
    }
}

task TPatternJ() {
    real angleT = 360 / 36;
    loop {
        for (int i = 0; i <= 774; i++) {
            CreateShotA1(MID_X + 24*cos(angleT), MID_Y + 24*sin(angleT), 1, angleT, i, 0);
            angleT += 360 / 18;
            yield;
        }
    }
}

task TPatternK() { //Emerald Megalith
    real x = rand(35, GetStgFrameWidth() - 35);
    real y = rand(60, MID_Y - 65);
    real speed = rand(1.4, 2.8);

    ascent (i in 0..30) {
        int graphic = rand_int(0, 1) ? SHOT_GREEN+CRYSTAL_S : SHOT_GREEN+GEM;
        real modif = rand(1, 1.3);
        CreateShotA1(x, y, speed * modif, rand(0, 360), graphic, 0);
    }

    ascent (i in 0..3) {
        CreateShotA1(x, y, speed, 135 - i*45, SHOT_GREEN+CRYSTAL_A, 0);
    }
}

task TPatternL() {
    real angleT = 0;
    int index = 0;
    loop {
        for (int i = index; i < 18; i++) {
            CreateShotUA1(MID_X + 48 * cos(angleT), MID_Y + 48 * sin(angleT), 1, angleT, i+YINYANG_S, 0, i+SPAWN_S+SIZE_8, 0);
            angleT += 360 / 18;
        }
        angleT += 6;
        wait(24);
        for (int i = index; i < 18; i++) {
            CreateShotUA1(MID_X + 48 * cos(angleT), MID_Y + 48 * sin(angleT), 1, angleT, i+BOUNCY_BALL, 0, i+SPAWN_E+SIZE_8, 0);
            angleT += 360 / 18;
        }
        angleT += 6;
        wait(24);
        for (int i = index; i < 18; i++) {
            CreateShotUA1(MID_X + 48 * cos(angleT), MID_Y + 48 * sin(angleT), 1, angleT, i+SPARKLE, 0, i+SPAWN_S+SIZE_16, 0);
            angleT += 360 / 18;
        }
        angleT += 6;
        wait(24);
        for (int i = index; i < 18; i++) {
            CreateShotUA1(MID_X + 48 * cos(angleT), MID_Y + 48 * sin(angleT), 1, angleT, i+GEM, 0, i+SPAWN_E+SIZE_16, 0);
            angleT += 360 / 18;
        }
        angleT += 6;
        wait(24);
        for (int i = index; i < 18; i++) {
            CreateShotUA1(MID_X + 48 * cos(angleT), MID_Y + 48 * sin(angleT), 1, angleT, i+YINYANG_A, 0, i+SPAWN_S+SIZE_32, 0);
            angleT += 360 / 18;
        }
        angleT += 6;
        wait(24);
        for (int i = index; i < 18; i++) {
            CreateShotUA1(MID_X + 48 * cos(angleT), MID_Y + 48 * sin(angleT), 1, angleT, i+FIRE_A, 0, i+SPAWN_E+SIZE_32, 0);
            angleT += 360 / 18;
        }
        angleT += 6;
        wait(24);
    }
}

task TPatternM() { //Delete effects
    real angleT = 0;
    int i = 0;
    loop (72) {
        CreateShotUA1(MID_X + 72 * cos(angleT), MID_Y + 72 * sin(angleT), 0, angleT, PELLET+(i%18), 0, i);
        angleT += 360/72;
        i++;
    }
    loop (18) {
        CreateShotUA1(MID_X + 92 * cos(angleT), MID_Y + 92 * sin(angleT), 0, angleT, BALL_L+(i%18), 0, i);
        angleT += 360/18;
        i++;
    }
    loop (18) {
        CreateShotUA1(MID_X + 145 * cos(angleT), MID_Y + 145 * sin(angleT), 0, angleT, BUBBLE+(i%18), 0, i);
        angleT += 360/18;
        i++;
    }
}