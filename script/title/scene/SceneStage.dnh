//Stage Control Script
#include "./../lib/lib_TitleCommon.dnh"
#include "./../lib/lib_TitleUtil.dnh"
#include "./../../lib/lib_HighScore.dnh"

int _stageEvent;
bool _pauseEnable;
string _dialoguePath;

@Initialize {
    SetAreaCommonData(AREA_TITLE, "SCRIPT_STAGE", GetOwnScriptID());
    SetAutoDeleteObject(true);
    TStageScene();
    ClearBGM();
}

@Event {
    alternative (GetEventType())
    case (EV_PAUSE_ENABLE) {
        _pauseEnable = GetEventArgument(0);
    }
    case (EV_STAGE_EVENT) {
        int event = GetEventArgument(0);
        alternative (event)
        case (STAGE_DIALOGUE) {
            _stageEvent = event;
            _dialoguePath = GetEventArgument(1);
        }
        others { _stageEvent = event; }
    }
}

@MainLoop { yield; }

task TStageScene() {
    int gameMode        = GetGameMode();
    string pathPlayer   = SCRIPT_PLAYERS[GetPlayerType()];
    int stageIndex      = GetStageIndex();
    string replayPath   = GetAreaCommonData(AREA_TITLE, "ReplayPath", ""); //TODO replay pathing

    _stageEvent = STAGE_NONE;
    _pauseEnable = false;
    _dialoguePath = "";

    //reset common data areas before running a new stage
    ClearAreaCommonData(AREA_STAGE);
    ClearAreaCommonData(AREA_SYSTEM);

    InitializeStageScene();

    if (length(replayPath) > 0) SetStageReplayFile(replayPath);

    string stageScript;
    alternative (gameMode)
    case (GAME_MAIN) { stageScript = GetStagePath(stageIndex); }
    case (GAME_SPELL) { stageScript = DIR_STG ~ "Stage_SpellPractice.dnh"; }

    wait(20);

    StartStage();

    loop {
        //--------------------------------------------------------------------
        //Stage Event Handling
        //--------------------------------------------------------------------
        //Player pause
        if (GetVirtualKeyState(VK_PAUSE) == KEY_PUSH && _pauseEnable && _stageEvent == STAGE_NONE) {
            alternative (gameMode)
            case (GAME_MAIN) _stageEvent = STAGE_PAUSE;
            case (GAME_SPELL) _stageEvent = STAGE_PAUSE_SPELL;
        }
        //stage event (any event that results in termination shouldn't reset _stageEvent)
        if (_stageEvent != STAGE_NONE) {
            alternative (_stageEvent)
            case (STAGE_PAUSE, STAGE_PAUSE_SPELL, STAGE_GAMEOVER) { //pause and continue menus
                int menuResult = StageMenu(_stageEvent);
                HandleMenuResult(menuResult, false);
                if (menuResult == RESULT_RETRY) return;
            }
            case (STAGE_DIALOGUE) {
                RunDialogue(_dialoguePath);
                _stageEvent = STAGE_NONE;
            }
            case (STAGE_VICTORY) {
                EndStage();
            }
            case (STAGE_VICTORY_SPELL) {
                SetTransitionTexture();
                StageCleared();
            }
            case (STAGE_GAMEOVER_SPELL) {
                SetTransitionTexture();
                TerminateStageScene();
            }
        }
        //--------------------------------------------------------------------
        //Stage Result
        //--------------------------------------------------------------------
        int stageState = GetStageSceneState();
        if (stageState == STAGE_STATE_FINISHED) {
            //FinalizeStageScene(); WHY DO YOU CRASH AFTER RESTARTS

            //TODO handle if replay
            int stageResult = GetStageSceneResult();
            alternative (stageResult)
            case (STAGE_RESULT_CLEARED) { //Game Won
                WriteLog("won");
                alternative(_stageEvent)
                case (STAGE_VICTORY) { //game clear
                    //TODO ending cutscene, credits, tsuba unlock etc.
                    WriteLog("stage victory");
                }
                case (STAGE_VICTORY_SPELL) { //spell practice clear
                    WriteLog("stage victory spell");
                    int menuResult = StageMenu(_stageEvent);
                    HandleMenuResult(menuResult, true);
                    if (menuResult == RESULT_RETRY) return;
                }
                break;
            }
            case (STAGE_RESULT_BREAK_OFF) { //Exit Game
                WriteLog("break off");
                alternative (_stageEvent)
                case (STAGE_GAMEOVER) { //quit from continue prompt
                    //ask to save replay OR get replay save confirmation from previous menu?
                    WriteLog("stage gameover");
                }
                case (STAGE_GAMEOVER_SPELL) { //spell practice fail
                    WriteLog("stage gameover spell");
                    int menuResult = StageMenu(_stageEvent);
                    HandleMenuResult(menuResult, true);
                    if (menuResult == RESULT_RETRY) return;
                }
                break;
            }
        }
        yield;
    }

    TReturnToTitle();

    function<void> StartStage() {
        SetStageMainScript(stageScript);
        SetStagePlayerScript(pathPlayer);
        StartStageScene();
    }

    function<int> StageMenu(_menuType) {
        if (_menuType == STAGE_PAUSE) StopBGM(); //pause music
        SetTransitionTexture(); //save current frame as pause bg
        PauseStageScene(true); //pause stage
        
        string pathScript = GetCurrentScriptDirectory() ~ "../../system/StageMenu.dnh";
        
        //Run pause script
        int idScript = LoadScript(pathScript);
        SetScriptArgument(idScript, 0, _menuType);
        StartScript(idScript);
        
        while (!IsCloseScript(idScript)) yield;

        return GetScriptResult(idScript);
    }

    function<void> HandleMenuResult(int menuResult_, bool isStageEnd_) {
        alternative (menuResult_)
        case (RESULT_CANCEL) {
            ResumeBGM();
            PauseStageScene(false);
            _stageEvent = STAGE_NONE;
        }
        case (RESULT_RETRY) {
            if (gameMode == GAME_MAIN) ClearBGM();
            if (GetAreaCommonData(AREA_STAGE, "Continues", 0) == 0) { //set high score before erasing by restart
                HS_SetHighScore(GetScore(), HS_GetDefaultScore(gameMode));
            }
            if (!isStageEnd_) TerminateStageScene();
            TStageScene();
        }
        case (RESULT_CONTINUE) {
            if (GetAreaCommonData(AREA_STAGE, "Continues", 0) == 0) { //set high score before erasing by continue
                HS_SetHighScore(GetScore(), HS_GetDefaultScore(gameMode));
            }
            NotifyEvent(GetAreaCommonData(AREA_STAGE, "SCRIPT_STAGE", 0), EV_CONTINUE, 0);
            PauseStageScene(false);
            _stageEvent = STAGE_NONE;
        }
        case (RESULT_SAVE_REPLAY) {
            //replay save scene toggle
        }
        case (RESULT_END) {
            if (!isStageEnd_) TerminateStageScene();
            wait(60);
        }
    }

    function<void> RunDialogue(string path_) {
        SetTransitionTexture();
        PauseStageScene(true);

        //Start dialogue
        int idScript = LoadScript(path_);
        StartScript(idScript);

        while (!IsCloseScript(idScript)) yield;

        //resume
        PauseStageScene(false);
        UnloadScriptFromCache(path_);
        return;
    }

    function<void> EndStage() { //fade to black, dim music
        SetTransitionTexture();
        RenderToTextureA1(RT_ENDSCREEN, RP_STG_END, RP_STG_END, true);
        StageCleared();
        ClearBGM();

        int bg = InitSprite2D(0, 0, WINDOW_WIDTH, WINDOW_HEIGHT, RT_SCREENSHOT, RP_UI_BG);
        int objBlack = InitSprite2D(0, 0, MAX_X, MAX_Y, RP_UI_IMG);
        int objText = InitSprite2D(0, 0, WINDOW_WIDTH, WINDOW_HEIGHT, RT_ENDSCREEN, RP_UI_IMG);
        ObjRender_SetColor(objBlack, COLOR_BLACK);
        ObjRender_SetPosition(objBlack, 32, 16, 1); //offset to cover game window

        int fadeTime = 180;
        for (int i = 1; i <= fadeTime; i++) {
            ObjRender_SetAlpha(objBlack, Interpolate_Linear(0, 255, i / as_float(fadeTime)));
            yield;
        }

        wait(30);
        Obj_Delete(bg);
        Obj_Delete(objBlack);
        Obj_Delete(objText);
        wait(60);
    }
}

function<void> StageCleared() {
    NotifyEvent(GetStageScriptID(), EV_STAGE_VICTORY, 0);
}

function<void> SetTransitionTexture() { //saves the current frame to be used as the background for pause/dialogue screens
	RenderToTextureA1(RT_SCREENSHOT, RP_UI_MIN, RP_STG_BG, false);
    RenderToTextureA1(RT_SCREENSHOT, RP_STG_TRANSITION2, RP_UI_MAX, false);
}

function<void> TReturnToTitle() { //Run title screen
    //TODO check if a replay just played
    int gameMode = GetGameMode(); //before clearing common data, get game mode

    if (GetAreaCommonData(AREA_STAGE, "Continues", 0) == 0) {
        HS_SetHighScore(GetScore(), HS_GetDefaultScore(gameMode));
    }
    //save data
    CD_SaveScore();
    CD_SaveResult();

    //reset relevant common data
    ClearAreaCommonData(AREA_STAGE);
    ClearAreaCommonData(AREA_SYSTEM);

    //run title screen
    string path = GetCurrentScriptDirectory() ~ "../Title.dnh";
    int ID = LoadScript(path);
    int preloadIndex = -1;
    if (gameMode == GAME_SPELL) preloadIndex = 1; //preload spell practice
    SetScriptArgument(ID, 0, preloadIndex); //preload spell practice
    StartScript(ID);

    CloseScript(GetOwnScriptID());
}

//return stage script using stage index
function<string> GetStagePath(int index_) {
    alternative (index_)
    case (0) return DIR_STG ~ "tsurubami/tsuruStage.dnh"; //yabusame stage
    case (1) return DIR_STG ~ "tsurubami/tsuruStage.dnh"; //tsubakura stage
    others assert(false, index_ ~ " is an invalid stage index.");
}