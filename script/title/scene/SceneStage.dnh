//Stage Control Script
#include "./../lib/lib_TitleCommon.dnh"
#include "./../lib/lib_TitleUtil.dnh"
#include "./../../lib/lib_HighScore.dnh"

int _stageEvent;
bool _pauseEnable;
string _dialoguePath;

@Initialize {
    SetAreaCommonData(AREA_TITLE, "SCRIPT_STAGE", GetOwnScriptID());
    SetAutoDeleteObject(true);
    TStageScene();
    ClearBGM();
}

@Event {
    alternative (GetEventType())
    case (EV_PAUSE_ENABLE) {
        _pauseEnable = GetEventArgument(0);
    }
    case (EV_STAGE_EVENT) {
        int event = GetEventArgument(0);
        alternative (event)
        case (STAGE_DIALOGUE) {
            _stageEvent = event;
            _dialoguePath = GetEventArgument(1);
        }
        others { _stageEvent = GetEventArgument(0); }
    }
}

@MainLoop { yield; }

task TStageScene() {
    int gameMode        = GetGameMode();
    string pathPlayer   = SCRIPT_PLAYERS[GetPlayerType()];
    int stageIndex      = GetStageIndex();
    string replayPath   = GetAreaCommonData(AREA_TITLE, "ReplayPath", ""); //TODO replay pathing

    _stageEvent = STAGE_NONE;
    _pauseEnable = false;
    _dialoguePath = "";

    //reset common data areas before running a new stage
    ClearAreaCommonData(AREA_STAGE);
    ClearAreaCommonData(AREA_SYSTEM);

    InitializeStageScene();

    if (length(replayPath) > 0) SetStageReplayFile(replayPath);

    string stageScript;
    alternative (gameMode)
    case (GAME_MAIN) { stageScript = GetStagePath(stageIndex); }
    case (GAME_SPELL) { stageScript = DIR_STG ~ "Stage_SpellPractice.dnh"; }

    wait(20);

    StartStage();

    loop {
        //--------------------------------------------------------------------
        //Stage Event Handling
        //--------------------------------------------------------------------
        //Player pause
        if (GetVirtualKeyState(VK_PAUSE) == KEY_PUSH && _pauseEnable && _stageEvent == STAGE_NONE) {
            alternative (gameMode)
            case (GAME_MAIN) _stageEvent = STAGE_PAUSE;
            case (GAME_SPELL) _stageEvent = STAGE_PAUSE_SPELL;
        }
        //stage event
        if (_stageEvent != STAGE_NONE) {
            alternative (_stageEvent)
            case (STAGE_PAUSE, STAGE_PAUSE_SPELL, STAGE_VICTORY_SPELL, STAGE_GAMEOVER, STAGE_GAMEOVER_SPELL) { //pause menus
                int menuResult = StageMenu(_stageEvent);
                alternative (menuResult)
                case (RESULT_CANCEL) {
                    ResumeBGM();
                    PauseStageScene(false);
                }
                case (RESULT_RETRY) {
                    if (gameMode == GAME_MAIN) ClearBGM();
                    if (GetAreaCommonData(AREA_STAGE, "Continues", 0) == 0) { //set high score before erasing by restart
                        HS_SetHighScore(GetScore(), HS_GetDefaultScore(gameMode));
                    }
                    TerminateStageScene();
                    TStageScene();
                    return;
                }
                case (RESULT_CONTINUE) {
                    if (GetAreaCommonData(AREA_STAGE, "Continues", 0) == 0) { //set high score before erasing by continue
                        HS_SetHighScore(GetScore(), HS_GetDefaultScore(gameMode));
                    }
                    NotifyEvent(GetAreaCommonData(AREA_STAGE, "SCRIPT_STAGE", 0), EV_CONTINUE, 0);
                    PauseStageScene(false);
                }
                case (RESULT_END) {
                    wait(60);
                    TerminateStageScene();
                }
            }
            case (STAGE_DIALOGUE) {
                RunDialogue(_dialoguePath);
            }
            _stageEvent = STAGE_NONE;
        }
        //--------------------------------------------------------------------
        //Stage Result Upon Ending
        //--------------------------------------------------------------------
        int stageState = GetStageSceneState();
        if (stageState == STAGE_STATE_FINISHED) {
            int stageResult = GetStageSceneResult();

            alternative (stageResult)
            case (STAGE_RESULT_CLEARED) { //Game Won
                WriteLog("won");
                //TODO screen cap and fade out for 300 frames. might have to put elsewhere?
                break;
            }
            case (STAGE_RESULT_PLAYER_DOWN) { //Game Over (likely does not trigger ever)
                WriteLog("game over");
                break;
            }
            case (STAGE_RESULT_BREAK_OFF) { //Exit Game
                WriteLog("break off"); //TODO need some way to differentiate between quit from pause and quit from continue
                break;
            }
        }
        yield;
    }

    TReturnToTitle();

    function<void> StartStage() {
        SetStageMainScript(stageScript);
        SetStagePlayerScript(pathPlayer);
        StartStageScene();
    }

    function<int> StageMenu(_menuType) {
        if (gameMode == GAME_MAIN && _menuType == STAGE_PAUSE) StopBGM(); //pause music
        SetTransitionTexture(); //save current frame as pause bg
        PauseStageScene(true); //pause stage
        
        string pathScript = GetCurrentScriptDirectory() ~ "../../system/Pause.dnh";
        
        //Run pause script
        int idScript = LoadScript(pathScript);
        SetScriptArgument(idScript, 0, _menuType);
        StartScript(idScript);
        
        while (!IsCloseScript(idScript)) yield;

        return GetScriptResult(idScript);
    }

    function<void> RunDialogue(string path_) {
        SetTransitionTexture();
        PauseStageScene(true);

        //Start dialogue
        int idScript = LoadScript(path_);
        StartScript(idScript);

        while (!IsCloseScript(idScript)) yield;

        //resume
        PauseStageScene(false);
        UnloadScriptFromCache(path_);
        return;
    }
}

function<void> SetTransitionTexture() { //saves the current frame to be used as the background for pause/dialogue screens
	RenderToTextureA1(RT_SCREENSHOT, RP_UI_MIN, RP_STG_BG, false);
    RenderToTextureA1(RT_SCREENSHOT, RP_STG_TRANSITION2, RP_UI_MAX, false);
}

function<void> TReturnToTitle() { //Run title screen
    //TODO check if a replay just played
    int gameMode = GetGameMode(); //before clearing common data, get game mode

    if (GetAreaCommonData(AREA_STAGE, "Continues", 0) == 0) {
        HS_SetHighScore(GetScore(), HS_GetDefaultScore(gameMode));
    }
    //save data
    CD_SaveScore();
    CD_SaveResult();

    //reset relevant common data
    ClearAreaCommonData(AREA_STAGE);
    ClearAreaCommonData(AREA_SYSTEM);

    //run title screen
    string path = GetCurrentScriptDirectory() ~ "../Title.dnh";
    int ID = LoadScript(path);
    int preloadIndex = -1;
    if (gameMode == GAME_SPELL) preloadIndex = 1; //preload spell practice
    SetScriptArgument(ID, 0, preloadIndex); //preload spell practice
    StartScript(ID);

    CloseScript(GetOwnScriptID());
}

//return stage script using stage index
function<string> GetStagePath(int index_) {
    alternative (index_)
    case (0) return DIR_STG ~ "Tsurubami/tsuruStage.dnh"; //yabusame stage
    case (1) return DIR_STG ~ "Tsurubami/tsuruStage.dnh"; //tsubakura stage
    others assert(false, index_ ~ " is an invalid stage index.");
}