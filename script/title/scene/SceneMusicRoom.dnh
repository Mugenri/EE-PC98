//Music Room
#include "../lib/BGMData.dnh"

function<void> SceneMusicRoom() {
    bool exitFlag = false;

    int selectMax = 19; //number of tracks - 1 (starts from index 0)
    int indexListSize = 7; //number of tracks on screen at once - 1 (starts from index 0)
    int indexListTop = 0; //index at the top of the track list, used for scrolling the list

    int indexCurrent = 0;

    bool revealPrompt = false; //has the player attempted to play an undiscovered track?
    int revealIndex = -1; //used to reveal unknown tracks on prompt

    TCreateMenuGraphicsMusic();
    //default texts
    int playingText = CreateText(32, 268, GetBGMText(-1)[0], COLOR_WHITE); //currently playing track
    int descriptionText = CreateText(32, 288, GetBGMText(-1)[1], COLOR_WHITE); //track comments

    //Create Menu Items
    {
        int menuX = 32;
        int menuY = 64;
        ascent (i in 0..indexListSize + 1) {
            TCreateMenuItemMusic(i, menuX, menuY);
            menuY+= 16;
        }
    }
    ClearBGM(); //fade out title music
    wait(15); //wait for screen fade from previous menu to clear
    WaitKeysFree([VK_UP, VK_DOWN, VK_OK, VK_CANCEL, VK_PAUSE]);
    loop {
        int userKey = CheckKeyPressed([VK_UP, VK_DOWN, VK_OK, VK_CANCEL, VK_PAUSE]);
        alternative (userKey)
        case (VK_UP) {
            //CallSFX(SND_TT_SELECT);
            indexCurrent = IncrementIndex(indexCurrent, -1, 0, selectMax);
            if (revealPrompt == true) {
                CancelReveal();
            }
        }
        case (VK_DOWN) {
            //CallSFX(SND_TT_SELECT);
            indexCurrent = IncrementIndex(indexCurrent, 1, 0, selectMax);
            if (revealPrompt == true) {
                CancelReveal();
            }
        }
        case (VK_OK) {
            MenuSelect();
        }
        case (VK_CANCEL, VK_PAUSE) {
            CallSFX(SND_TT_CANCEL);
            ScreenBlackout(10, 5, 10, COLOR_BLACK);
            ClearBGM();
            wait(10);
            break;
        }
        //check if cursor has scrolled outside music list
        if (indexCurrent > indexListTop + indexListSize) indexListTop = indexCurrent - indexListSize;
        else if (indexCurrent < indexListTop) indexListTop = indexCurrent;
    }
    exitFlag = true;
    Obj_Delete(descriptionText);
    Obj_Delete(playingText);

    function<void> MenuSelect() {
        //play music track if heard previously, change description text
        if (!CD_GetBGMHeardFlag(indexCurrent)) { //reveal track
            if (revealPrompt) {
                revealIndex = indexCurrent;
                revealPrompt = false;
            } else { //prompt player on selecting undiscovered music
                ObjText_SetVertexColor(playingText, 0xFF000000 + COLOR_RED);
                ObjText_SetVertexColor(descriptionText, 0xFF000000 + COLOR_RED);
                ObjText_SetText(playingText, "???");
                ObjText_SetText(descriptionText, "Are you sure?");
                revealPrompt = true;
                return;
            }
        }
        ClearBGM(); //allows restarting the same track if it's already playing
        yield;
        StartBGM(indexCurrent, 15, 15);
        ObjText_SetVertexColor(playingText, 0xFF000000 + COLOR_WHITE);
        ObjText_SetVertexColor(descriptionText, 0xFF000000 + COLOR_WHITE);
        ObjText_SetText(playingText, GetBGMText(indexCurrent)[0]);
        ObjText_SetText(descriptionText, GetBGMText(indexCurrent)[1]);
    }

    task TCreateMenuGraphicsMusic() {
        int bg = ObjPrim_Create(OBJ_SPRITE_2D);
        ObjRender_SetColor(bg, COLOR_BLACK);
        Obj_SetRenderPriorityI(bg, RP_UI_BG);
        ObjSprite2D_SetSourceRect(bg, 0, 0, 640, 400);
        ObjSprite2D_SetDestRect(bg, 0, 0, 640, 400);

        int linesH = CreateLinesH();
        int linesV = CreateLinesV();

        while (!exitFlag) yield;
        Obj_Delete(bg);
        Obj_Delete(linesH);
        Obj_Delete(linesV);

        function<int> CreateLinesH() {
            int lines = ObjPrim_Create(OBJ_PRIMITIVE_2D);
            ObjPrim_SetPrimitiveType(lines, PRIMITIVE_LINELIST);
            ObjPrim_SetVertexCount(lines, 32);
            Obj_SetRenderPriorityI(lines, RP_UI_BG);

            int i = 0;
            real dist = 90;
            loop (8) {
                ObjPrim_SetVertexPosition(lines, i, 0, 200 + dist, 1);
                ObjPrim_SetVertexPosition(lines, i + 1, 740, 200, 1);
                ObjPrim_SetVertexPosition(lines, 31 - i, 0, 200 - dist, 1);
                ObjPrim_SetVertexPosition(lines, 30 - i, 740, 200, 1);
                ObjPrim_SetVertexColor(lines, i, COLOR_GREEN_D);
                ObjPrim_SetVertexColor(lines, i + 1, COLOR_GREEN_D);
                ObjPrim_SetVertexColor(lines, 31 - i, COLOR_GREEN_D);
                ObjPrim_SetVertexColor(lines, 30 - i, COLOR_GREEN_D);
                i += 2;
                dist += 160;
            }
            return lines;
        }

        function<int> CreateLinesV() {
            int lines = ObjPrim_Create(OBJ_PRIMITIVE_2D);
            ObjPrim_SetPrimitiveType(lines, PRIMITIVE_LINELIST);
            ObjPrim_SetVertexCount(lines, 24);
            Obj_SetRenderPriorityI(lines, RP_UI_BG);
            
            int i = 0;
            async {
                loop {
                    TMoveLineV(i);
                    i += 2;
                    if (i > 23) i = 0;
                    wait(30);
                }
            }

            return lines;

            task TMoveLineV(int index_) {
                real xPos = 650;
                real speed = 0;
                ObjPrim_SetVertexColor(lines, index_, COLOR_GREEN_D);
                ObjPrim_SetVertexColor(lines, index_ + 1, COLOR_GREEN_D);
                while (xPos > 600) {
                    xPos -= speed;
                    ObjPrim_SetVertexPosition(lines, index_, xPos, 0, 1);
                    ObjPrim_SetVertexPosition(lines, index_ + 1, xPos, 640, 1);
                    speed += 0.01;
                    yield;
                }
                ObjPrim_SetVertexColor(lines, index_, COLOR_GREEN);
                ObjPrim_SetVertexColor(lines, index_ + 1, COLOR_GREEN);
                while (xPos > 0) {
                    xPos -= speed;
                    ObjPrim_SetVertexPosition(lines, index_, xPos, 0, 1);
                    ObjPrim_SetVertexPosition(lines, index_ + 1, xPos, 640, 1);
                    speed += 0.02;
                    yield;
                }
            }
        }
    }

    task TCreateMenuItemMusic(int index_, int x_, int y_) {
        int objText;
        int bgmID = indexListTop + index_; //actual track number = index at top of list + position in the list
        string indexNumber = StringFormat("%2.0d%s", "ds", bgmID + 1, ". "); //prepended track number

        //Initial list creation
        if (!CD_GetBGMHeardFlag(bgmID)) {
            objText = CreateText(x_, y_, indexNumber ~ "???", COLOR_WHITE);
        } else {
            objText = CreateText(x_, y_, indexNumber ~ GetBGMText(bgmID)[0], COLOR_WHITE);
        }

        while (!exitFlag) {
            if (indexListTop + index_ != bgmID) { //update list if it scrolls beyond the current boundaries
                bgmID = indexListTop + index_;
                indexNumber = StringFormat("%2.0d%s", "ds", bgmID + 1, ". ");
                if (!CD_GetBGMHeardFlag(bgmID)) ObjText_SetText(objText, indexNumber ~ "???");
                else ObjText_SetText(objText, indexNumber ~ GetBGMText(bgmID)[0]);
            }
            if (revealIndex == indexListTop + index_) { //play undiscovered track
                ObjText_SetText(objText, indexNumber ~ GetBGMText(bgmID)[0]);
                revealIndex = -1;
            }
            ObjText_SetVertexColor(objText, 0xFF000000 + (bgmID == indexCurrent ? COLOR_YELLOW : COLOR_WHITE));
            yield;
        }
        Obj_Delete(objText);
    }

    function<void> CancelReveal() { //resets currently playing track and desription text upon cancelling a track reveal
        ObjText_SetVertexColor(playingText, 0xFF000000 + COLOR_WHITE);
        ObjText_SetVertexColor(descriptionText, 0xFF000000 + COLOR_WHITE);
        ObjText_SetText(playingText, GetBGMText(GetAreaCommonData(AREA_TITLE, "BGM_ID", -1))[0]);
        ObjText_SetText(descriptionText, GetBGMText(GetAreaCommonData(AREA_TITLE, "BGM_ID", -1))[1]);
        revealPrompt = false;
    }
}