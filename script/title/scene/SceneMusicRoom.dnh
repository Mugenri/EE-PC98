//Music Room
#include "../lib/BGMData.dnh"

function<void> SceneMusicRoom() {
    bool exitFlag = false;

    int selectMax = 2; //number of tracks - 1 (starts from index 0)
    int indexListSize = 2; //number of tracks on screen at once - 1 (starts from index 0)
    int indexListTop = 0; //index at the top of the track list, used for scrolling the list

    int indexCurrent = 0;

    bool revealPrompt = false; //has the player attempted to play an undiscovered track?
    int revealIndex = -1; //used to reveal unknown tracks on prompt

    TCreateMenuGraphicsMusic();
    //default texts
    int playingText = CreateText(32, 247, BGM_GetText(-1)[0], COLOR_WHITE); //currently playing track
    int descriptionText = CreateText(32, 270, BGM_GetText(-1)[1], COLOR_WHITE); //track comments
    ObjText_SetMaxWidth(playingText, 412);
    ObjText_SetMaxWidth(descriptionText, 412);
    ObjText_SetLinePitch(descriptionText, 0);

    //Create Menu Items
    {
        int menuX = 32;
        int menuY = 64;
        ascent (i in 0..indexListSize + 1) {
            TCreateMenuItemMusic(i, menuX, menuY);
            menuY+= 16;
        }
    }
    ClearBGM(); //fade out title music
    wait(15); //wait for screen fade from previous menu to clear
    WaitKeysFree([VK_UP, VK_DOWN, VK_OK, VK_CANCEL, VK_PAUSE]);
    loop {
        int userKey = CheckKeyPressed([VK_UP, VK_DOWN, VK_OK, VK_CANCEL, VK_PAUSE]);
        alternative (userKey)
        case (VK_UP) {
            //CallSFX(SND_TT_SELECT);
            indexCurrent = IncrementIndex(indexCurrent, -1, 0, selectMax);
            if (revealPrompt == true) CancelReveal();
        }
        case (VK_DOWN) {
            //CallSFX(SND_TT_SELECT);
            indexCurrent = IncrementIndex(indexCurrent, 1, 0, selectMax);
            if (revealPrompt == true) CancelReveal();
        }
        case (VK_OK) MenuSelect();
        case (VK_CANCEL, VK_PAUSE) {
            CallSFX(SND_TT_CANCEL);
            ScreenBlackout(10, 5, 10, COLOR_BLACK);
            ClearBGM();
            wait(10);
            break;
        }
        //check if cursor has scrolled outside music list
        if (indexCurrent > indexListTop + indexListSize) indexListTop = indexCurrent - indexListSize;
        else if (indexCurrent < indexListTop) indexListTop = indexCurrent;
    }
    exitFlag = true;
    Obj_Delete(descriptionText);
    Obj_Delete(playingText);

    function<void> MenuSelect() {
        //play music track if heard previously, change description text
        if (!CD_GetBGMHeard(indexCurrent)) { //reveal track
            if (revealPrompt) {
                revealIndex = indexCurrent;
                revealPrompt = false;
            } else { //prompt player on selecting undiscovered music
                ObjText_SetVertexColor(playingText, 0xFF000000 + COLOR_RED);
                ObjText_SetVertexColor(descriptionText, 0xFF000000 + COLOR_RED);
                ObjText_SetText(playingText, "???");
                ObjText_SetText(descriptionText, "Are you sure?");
                revealPrompt = true;
                return;
            }
        }
        ClearBGM(); //allows restarting the same track if it's already playing
        yield;
        StartBGM(indexCurrent, 15, 15);
        ObjText_SetVertexColor(playingText, 0xFF000000 + COLOR_WHITE);
        ObjText_SetVertexColor(descriptionText, 0xFF000000 + COLOR_WHITE);
        ObjText_SetText(playingText, BGM_GetText(indexCurrent)[0]);
        ObjText_SetText(descriptionText, BGM_GetText(indexCurrent)[1]);
    }

    task TCreateMenuGraphicsMusic() {
        int bg = InitSprite2D(0, 0, WINDOW_WIDTH, WINDOW_HEIGHT, RP_UI_BG);
        ObjRender_SetColor(bg, COLOR_BLACK);

        int header = InitSprite2D(0, 0, 333, 44, IMG_TT_MUSIC, RP_UI_IMG);
        ObjRender_SetPosition(header, 25, 0, 1);

        int graphic = InitSprite2D(0, 44, 427, 357, IMG_TT_MUSIC, RP_UI_IMG);
        ObjRender_SetPosition(graphic, 25, 43, 1);
        int linesH = CreateLinesH();
        int linesV = CreateLinesV();

        while (!exitFlag) yield;
        Obj_Delete(bg);
        Obj_Delete(header);
        Obj_Delete(graphic);
        Obj_Delete(linesH);
        Obj_Delete(linesV);

        function<int> CreateLinesH() {
            int lines = InitPrim2D(PRIMITIVE_LINELIST, 36, RP_UI_BG);

            int i = 0;
            real dist = 90;
            loop (9) {
                ObjPrim_SetVertexPosition(lines, i, 0, 200 + dist, 1);
                ObjPrim_SetVertexPosition(lines, i + 1, 740, 200, 1);
                ObjPrim_SetVertexPosition(lines, 35 - i, 0, 200 - dist, 1);
                ObjPrim_SetVertexPosition(lines, 34 - i, 740, 200, 1);
                ObjPrim_SetVertexColor(lines, i, COLOR_GREEN_D);
                ObjPrim_SetVertexColor(lines, i + 1, COLOR_GREEN_D);
                ObjPrim_SetVertexColor(lines, 35 - i, COLOR_GREEN_D);
                ObjPrim_SetVertexColor(lines, 34 - i, COLOR_GREEN_D);
                i += 2;
                dist += 160;
            }
            return lines;
        }

        function<int> CreateLinesV() {
            int lines = InitPrim2D(PRIMITIVE_LINELIST, 24, RP_UI_BG);
            
            int i = 0;
            real time = 300;
            async {
                while (!exitFlag) {
                    for (int i = 0; i < 23; i += 2) {
                        if (exitFlag) break;
                        TMoveLineV(i);
                        wait(30);
                    }
                }
            }

            return lines;

            task TMoveLineV(int index_) {
                real xPos;
                ObjPrim_SetVertexColor(lines, index_, COLOR_GREEN_D);
                ObjPrim_SetVertexColor(lines, index_ + 1, COLOR_GREEN_D);
                for (int i = 1; i <= time; i++) {
                    xPos = Interpolate_Accelerate(WINDOW_WIDTH, 0, i / time);
                    ObjPrim_SetVertexPosition(lines, index_, xPos, 0, 1);
                    ObjPrim_SetVertexPosition(lines, index_ + 1, xPos, WINDOW_HEIGHT, 1);
                    yield;
                }
            }
        }
    }

    task TCreateMenuItemMusic(int index_, int x_, int y_) {
        int objText;
        int bgmID = indexListTop + index_; //actual track number = index at top of list + position in the list
        string indexNumber = StringFormat("%2.0d. ", "d", bgmID + 1); //prepended track number

        //Initial list creation
        if (!CD_GetBGMHeard(bgmID)) objText = CreateText(x_, y_, indexNumber ~ "???", COLOR_WHITE);
        else objText = CreateText(x_, y_, indexNumber ~ BGM_GetText(bgmID)[0], COLOR_WHITE);
        ObjText_SetMaxWidth(objText, 412);

        while (!exitFlag) {
            if (indexListTop + index_ != bgmID) { //update list if it scrolls beyond the current boundaries
                bgmID = indexListTop + index_;
                indexNumber = StringFormat("%2.0d. ", "d", bgmID + 1);
                if (!CD_GetBGMHeard(bgmID)) ObjText_SetText(objText, indexNumber ~ "???");
                else ObjText_SetText(objText, indexNumber ~ BGM_GetText(bgmID)[0]);
            }
            if (revealIndex == indexListTop + index_) { //play undiscovered track
                ObjText_SetText(objText, indexNumber ~ BGM_GetText(bgmID)[0]);
                revealIndex = -1;
            }
            ObjText_SetVertexColor(objText, 0xFF000000 + (bgmID == indexCurrent ? COLOR_YELLOW : COLOR_WHITE));
            yield;
        }
        Obj_Delete(objText);
    }

    function<void> CancelReveal() { //resets currently playing track and desription text upon cancelling a track reveal
        ObjText_SetVertexColor(playingText, 0xFF000000 + COLOR_WHITE);
        ObjText_SetVertexColor(descriptionText, 0xFF000000 + COLOR_WHITE);
        ObjText_SetText(playingText, BGM_GetText(GetCurrentBGMID())[0]);
        ObjText_SetText(descriptionText, BGM_GetText(GetCurrentBGMID())[1]);
        revealPrompt = false;
    }
}